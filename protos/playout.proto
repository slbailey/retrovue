// Repository: Retrovue-playout
// Component: Playout Engine Control API
// Purpose: Defines the canonical gRPC contract for managing playout channel lifecycle.
// Copyright (c) 2025 RetroVue
// NOTE: This file is the canonical contract between the Python ChannelManager and the C++ playout engine.

syntax = "proto3";

package retrovue.playout;

import "google/protobuf/descriptor.proto";

// Top-level API version constant for compatibility negotiation.
extend google.protobuf.FileOptions {
  string PLAYOUT_API_VERSION = 50000;
}

option (PLAYOUT_API_VERSION) = "1.0.0";

// TODO: Add telemetry streaming RPC once engine exposes metrics.
// TODO: Introduce status subscription for real-time channel health updates.
// TODO: Define plan delta messages to minimize payload size during updates.

// PlayoutControl exposes lifecycle management operations for playout channels.
service PlayoutControl {
  // StartChannel activates a playout channel with the provided plan on the target port.
  rpc StartChannel(StartChannelRequest) returns (StartChannelResponse);

  // UpdatePlan swaps the active plan for the given channel without interrupting playback.
  rpc UpdatePlan(UpdatePlanRequest) returns (UpdatePlanResponse);

  // StopChannel gracefully stops the active playout channel and releases resources.
  rpc StopChannel(StopChannelRequest) returns (StopChannelResponse);

  // GetVersion returns the API version implemented by the playout engine.
  rpc GetVersion(ApiVersionRequest) returns (ApiVersion);

  // Phase 9: Dual-producer control

  // LoadPreview loads a new asset into the preview slot for the given channel.
  // The engine will begin shadow decoding immediately, but will NOT switch live.
  rpc LoadPreview(LoadPreviewRequest) returns (LoadPreviewResponse);

  // SwitchToLive promotes the current preview slot to the live slot atomically.
  // Switching must be seamless: PTS continuity is preserved and the playout
  // sink cannot detect the switch.
  rpc SwitchToLive(SwitchToLiveRequest) returns (SwitchToLiveResponse);

  // Phase 8: byte transport attachment (Python owns stream sink, Air writes bytes)
  rpc AttachStream(AttachStreamRequest) returns (AttachStreamResponse);
  rpc DetachStream(DetachStreamRequest) returns (DetachStreamResponse);
}

// StartChannelRequest provides the context required to initialize a playout channel.
message StartChannelRequest {
  int32 channel_id = 1;      // Unique identifier for the target channel.
  string plan_handle = 2;    // Reference to the schedule plan that should begin playback.
  int32 port = 3;            // Local UDP/RTP port where the engine should output media.

  // Canonical per-channel program signal format.
  // JSON object; schema defined by PlayoutInstanceAndProgramFormatContract.md.
  // Required: defines video (width, height, frame_rate) and audio (sample_rate, channels).
  string program_format_json = 10;
}

// StartChannelResponse reports success or failure of the start operation.
message StartChannelResponse {
  bool success = 1;          // Indicates whether the channel started successfully.
  string message = 2;        // Optional diagnostic or error detail.
}

// UpdatePlanRequest identifies the channel and new plan to activate mid-stream.
message UpdatePlanRequest {
  int32 channel_id = 1;      // Target channel currently active on the engine.
  string plan_handle = 2;    // New plan to swap in for continued playback.
}

// UpdatePlanResponse indicates the result of applying the new plan.
message UpdatePlanResponse {
  bool success = 1;          // True if the plan update was accepted.
  string message = 2;        // Optional human-readable status message.
}

// StopChannelRequest identifies which channel to shut down.
message StopChannelRequest {
  int32 channel_id = 1;      // Channel identifier corresponding to the running instance.
}

// StopChannelResponse reports the outcome of the shutdown attempt.
message StopChannelResponse {
  bool success = 1;          // True if the channel stopped without error.
  string message = 2;        // Optional detail about the stop operation.
}

// ApiVersionRequest is intentionally empty; reserved for future handshake metadata.
message ApiVersionRequest {}

// ApiVersion communicates the protocol version supported by the engine.
message ApiVersion {
  string version = 1;        // Semantic version string of the playout control API.
}

// LoadPreviewRequest carries the next PlayoutSegment into the preview slot.
// Frame-indexed execution (INV-FRAME-001/002/003):
//   - start_frame: First frame index within asset (0-based). Air seeks to this frame.
//   - frame_count: Exact number of frames to play. Air stops after this count.
//   - fps_numerator/fps_denominator: Frame rate as rational (e.g. 30000/1001 = 29.97fps).
// SwitchToLive remains unchanged (no segment payload).
// INVARIANT: Core MUST provide frame-indexed fields. Air rejects requests without them.
message LoadPreviewRequest {
  int32 channel_id = 1;           // Target channel.
  string asset_path = 2;          // Fully-qualified media file path.
  int64 start_frame = 3;          // First frame index within asset (0-based). INV-FRAME-001.
  int64 frame_count = 4;          // Exact number of frames to play. INV-FRAME-002.
  int32 fps_numerator = 5;        // Frame rate numerator (e.g. 30000 for 29.97fps).
  int32 fps_denominator = 6;      // Frame rate denominator (e.g. 1001 for 29.97fps).
}

// LoadPreviewResponse reports the result of loading the preview asset.
message LoadPreviewResponse {
  bool success = 1;
  string message = 2;
  bool shadow_decode_started = 3;  // True if producer entered shadow mode.
  ResultCode result_code = 4;      // Phase 8: Typed result for Core to distinguish states
}

// SwitchToLiveRequest identifies the channel to switch from preview to live.
// P11C-001: INV-BOUNDARY-DECLARED-001 — Core declares target boundary time.
// P11D-012: INV-LEADTIME-MEASUREMENT-001 — issued_at_time_ms for lead-time evaluation.
message SwitchToLiveRequest {
  int32 channel_id = 1;     // Target channel.
  int64 target_boundary_time_ms = 2;  // Wall-clock ms when switch should occur (0 = immediate/legacy)
  int64 issued_at_time_ms = 3;  // Wall-clock ms when Core issued this request (for lead-time evaluation)
}

// SwitchToLiveResponse reports the result of the switch operation.
// P11B-001: INV-BOUNDARY-TOLERANCE-001 observability — completion time for delta measurement.
// P11D-004: violation_reason when result_code is PROTOCOL_VIOLATION.
message SwitchToLiveResponse {
  bool success = 1;
  string message = 2;
  // Optional: engine may report continuity details for debugging.
  bool pts_contiguous = 3;
  uint64 live_start_pts = 4;
  ResultCode result_code = 5;      // Phase 8: Typed result for Core to distinguish states
  int64 switch_completion_time_ms = 6;  // Wall-clock ms when switch actually completed
  string violation_reason = 7;     // P11D-004: Populated when result_code is PROTOCOL_VIOLATION
}

// Phase 8: Typed result codes for control operations
// Allows Core to distinguish between transient states and errors.
enum ResultCode {
  RESULT_CODE_UNSPECIFIED = 0;        // Default/unknown
  RESULT_CODE_OK = 1;                 // Operation succeeded
  RESULT_CODE_NOT_READY = 2;          // Transient: switch armed, awaiting readiness (don't panic, don't retry aggressively)
  RESULT_CODE_REJECTED_BUSY = 3;      // Operation forbidden in current state (e.g., LoadPreview while switch armed)
  RESULT_CODE_PROTOCOL_VIOLATION = 4; // Caller violated the protocol (e.g., SwitchToLive without LoadPreview)
  RESULT_CODE_FAILED = 5;             // Real error: operation failed permanently
}

// Phase 8: stream transport (Python creates sink, Air connects and writes bytes)

enum StreamTransport {
  STREAM_TRANSPORT_UNSPECIFIED = 0;
  STREAM_TRANSPORT_UNIX_DOMAIN_SOCKET = 1;  // recommended on Linux
  STREAM_TRANSPORT_TCP_LOOPBACK = 2;        // optional fallback (127.0.0.1:port)
}

message AttachStreamRequest {
  int32 channel_id = 1;

  // Where Air should write its output bytes.
  StreamTransport transport = 2;

  // For UNIX_DOMAIN_SOCKET: filesystem path like "/tmp/retrovue/ch_1.sock"
  // For TCP_LOOPBACK: host:port like "127.0.0.1:15001"
  string endpoint = 3;

  // If true, replacing an existing attachment is allowed.
  // If false, attaching when already attached is an error.
  bool replace_existing = 4;
}

message AttachStreamResponse {
  bool success = 1;
  string message = 2;

  // Optional: what Air actually used (in case of normalization).
  StreamTransport negotiated_transport = 3;
  string negotiated_endpoint = 4;
}

message DetachStreamRequest {
  int32 channel_id = 1;

  // If true, stop writing immediately even if live producer running.
  // Otherwise, detach happens at next safe boundary (optional policy).
  bool force = 2;
}

message DetachStreamResponse {
  bool success = 1;
  string message = 2;
}

