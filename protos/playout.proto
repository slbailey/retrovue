// Repository: Retrovue-playout
// Component: Playout Engine Control API
// Purpose: Defines the canonical gRPC contract for managing playout channel lifecycle.
// Copyright (c) 2025 RetroVue
// NOTE: This file is the canonical contract between the Python ChannelManager and the C++ playout engine.

syntax = "proto3";

package retrovue.playout;

import "google/protobuf/descriptor.proto";

// Top-level API version constant for compatibility negotiation.
extend google.protobuf.FileOptions {
  string PLAYOUT_API_VERSION = 50000;
}

option (PLAYOUT_API_VERSION) = "1.0.0";

// TODO: Add telemetry streaming RPC once engine exposes metrics.
// TODO: Introduce status subscription for real-time channel health updates.
// TODO: Define plan delta messages to minimize payload size during updates.

// PlayoutControl exposes lifecycle management operations for playout channels.
service PlayoutControl {
  // StartChannel activates a playout channel with the provided plan on the target port.
  rpc StartChannel(StartChannelRequest) returns (StartChannelResponse);

  // UpdatePlan swaps the active plan for the given channel without interrupting playback.
  rpc UpdatePlan(UpdatePlanRequest) returns (UpdatePlanResponse);

  // StopChannel gracefully stops the active playout channel and releases resources.
  rpc StopChannel(StopChannelRequest) returns (StopChannelResponse);

  // GetVersion returns the API version implemented by the playout engine.
  rpc GetVersion(ApiVersionRequest) returns (ApiVersion);

  // Phase 9: Dual-producer control

  // LoadPreview loads a new asset into the preview slot for the given channel.
  // The engine will begin shadow decoding immediately, but will NOT switch live.
  rpc LoadPreview(LoadPreviewRequest) returns (LoadPreviewResponse);

  // SwitchToLive promotes the current preview slot to the live slot atomically.
  // Switching must be seamless: PTS continuity is preserved and the playout
  // sink cannot detect the switch.
  rpc SwitchToLive(SwitchToLiveRequest) returns (SwitchToLiveResponse);

  // Phase 8: byte transport attachment (Python owns stream sink, Air writes bytes)
  rpc AttachStream(AttachStreamRequest) returns (AttachStreamResponse);
  rpc DetachStream(DetachStreamRequest) returns (DetachStreamResponse);
}

// StartChannelRequest provides the context required to initialize a playout channel.
message StartChannelRequest {
  int32 channel_id = 1;      // Unique identifier for the target channel.
  string plan_handle = 2;    // Reference to the schedule plan that should begin playback.
  int32 port = 3;            // Local UDP/RTP port where the engine should output media.

  // Canonical per-channel program signal format.
  // JSON object; schema defined by PlayoutInstanceAndProgramFormatContract.md.
  // Required: defines video (width, height, frame_rate) and audio (sample_rate, channels).
  string program_format_json = 10;
}

// StartChannelResponse reports success or failure of the start operation.
message StartChannelResponse {
  bool success = 1;          // Indicates whether the channel started successfully.
  string message = 2;        // Optional diagnostic or error detail.
}

// UpdatePlanRequest identifies the channel and new plan to activate mid-stream.
message UpdatePlanRequest {
  int32 channel_id = 1;      // Target channel currently active on the engine.
  string plan_handle = 2;    // New plan to swap in for continued playback.
}

// UpdatePlanResponse indicates the result of applying the new plan.
message UpdatePlanResponse {
  bool success = 1;          // True if the plan update was accepted.
  string message = 2;        // Optional human-readable status message.
}

// StopChannelRequest identifies which channel to shut down.
message StopChannelRequest {
  int32 channel_id = 1;      // Channel identifier corresponding to the running instance.
}

// StopChannelResponse reports the outcome of the shutdown attempt.
message StopChannelResponse {
  bool success = 1;          // True if the channel stopped without error.
  string message = 2;        // Optional detail about the stop operation.
}

// ApiVersionRequest is intentionally empty; reserved for future handshake metadata.
message ApiVersionRequest {}

// ApiVersion communicates the protocol version supported by the engine.
message ApiVersion {
  string version = 1;        // Semantic version string of the playout control API.
}

// LoadPreviewRequest carries the next PlayoutSegment into the preview slot.
// Segment semantics (see Phase 4 contract):
//   - start_offset_ms: media-relative only, never wall-clock. Air seeks by offset.
//   - hard_stop_time_ms: authoritative. If present, end_offset/duration never overrides it. Air may stop at or before this time, but must never play past it (encoder latency, PTS rounding, real hardware). Broadcast: <= boundary only.
// SwitchToLive remains unchanged (no segment payload).
message LoadPreviewRequest {
  int32 channel_id = 1;           // Target channel.
  string asset_path = 2;          // Fully-qualified media file path.
  int64 start_offset_ms = 3;      // Media-relative start position within the asset (milliseconds). Never wall-clock. Join-in-progress.
  int64 hard_stop_time_ms = 4;    // Wall-clock time when this segment must stop (epoch milliseconds). Authoritative. Engine may stop at or before this time; must never play past it.
}

// LoadPreviewResponse reports the result of loading the preview asset.
message LoadPreviewResponse {
  bool success = 1;
  string message = 2;
  bool shadow_decode_started = 3;  // True if producer entered shadow mode.
}

// SwitchToLiveRequest identifies the channel to switch from preview to live.
message SwitchToLiveRequest {
  int32 channel_id = 1;     // Target channel.
}

// SwitchToLiveResponse reports the result of the switch operation.
message SwitchToLiveResponse {
  bool success = 1;
  string message = 2;
  // Optional: engine may report continuity details for debugging.
  bool pts_contiguous = 3;
  uint64 live_start_pts = 4;
}

// Phase 8: stream transport (Python creates sink, Air connects and writes bytes)

enum StreamTransport {
  STREAM_TRANSPORT_UNSPECIFIED = 0;
  STREAM_TRANSPORT_UNIX_DOMAIN_SOCKET = 1;  // recommended on Linux
  STREAM_TRANSPORT_TCP_LOOPBACK = 2;        // optional fallback (127.0.0.1:port)
}

message AttachStreamRequest {
  int32 channel_id = 1;

  // Where Air should write its output bytes.
  StreamTransport transport = 2;

  // For UNIX_DOMAIN_SOCKET: filesystem path like "/tmp/retrovue/ch_1.sock"
  // For TCP_LOOPBACK: host:port like "127.0.0.1:15001"
  string endpoint = 3;

  // If true, replacing an existing attachment is allowed.
  // If false, attaching when already attached is an error.
  bool replace_existing = 4;
}

message AttachStreamResponse {
  bool success = 1;
  string message = 2;

  // Optional: what Air actually used (in case of normalization).
  StreamTransport negotiated_transport = 3;
  string negotiated_endpoint = 4;
}

message DetachStreamRequest {
  int32 channel_id = 1;

  // If true, stop writing immediately even if live producer running.
  // Otherwise, detach happens at next safe boundary (optional policy).
  bool force = 2;
}

message DetachStreamResponse {
  bool success = 1;
  string message = 2;
}

