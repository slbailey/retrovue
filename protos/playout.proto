// Repository: Retrovue-playout
// Component: Playout Engine Control API
// Purpose: Defines the canonical gRPC contract for managing playout channel lifecycle.
// Copyright (c) 2025 RetroVue
// NOTE: This file is the canonical contract between the Python ChannelManager and the C++ playout engine.

syntax = "proto3";

package retrovue.playout;

import "google/protobuf/descriptor.proto";

// Top-level API version constant for compatibility negotiation.
extend google.protobuf.FileOptions {
  string PLAYOUT_API_VERSION = 50000;
}

option (PLAYOUT_API_VERSION) = "1.0.0";

// TODO: Add telemetry streaming RPC once engine exposes metrics.
// TODO: Introduce status subscription for real-time channel health updates.
// TODO: Define plan delta messages to minimize payload size during updates.

// PlayoutControl exposes lifecycle management operations for playout channels.
service PlayoutControl {
  // StartChannel activates a playout channel with the provided plan on the target port.
  rpc StartChannel(StartChannelRequest) returns (StartChannelResponse);

  // UpdatePlan swaps the active plan for the given channel without interrupting playback.
  rpc UpdatePlan(UpdatePlanRequest) returns (UpdatePlanResponse);

  // StopChannel gracefully stops the active playout channel and releases resources.
  rpc StopChannel(StopChannelRequest) returns (StopChannelResponse);

  // GetVersion returns the API version implemented by the playout engine.
  rpc GetVersion(ApiVersionRequest) returns (ApiVersion);

  // Phase 9: Dual-producer control

  // LoadPreview loads a new asset into the preview slot for the given channel.
  // The engine will begin shadow decoding immediately, but will NOT switch live.
  rpc LoadPreview(LoadPreviewRequest) returns (LoadPreviewResponse);

  // SwitchToLive promotes the current preview slot to the live slot atomically.
  // Switching must be seamless: PTS continuity is preserved and the playout
  // sink cannot detect the switch.
  rpc SwitchToLive(SwitchToLiveRequest) returns (SwitchToLiveResponse);

  // Phase 8: byte transport attachment (Python owns stream sink, Air writes bytes)
  rpc AttachStream(AttachStreamRequest) returns (AttachStreamResponse);
  rpc DetachStream(DetachStreamRequest) returns (DetachStreamResponse);

  // ==========================================================================
  // BlockPlan Mode: 2-block window feeder execution
  // ==========================================================================
  // BlockPlan mode replaces segment-by-segment LoadPreview/SwitchToLive with
  // a deterministic CT-driven executor that maintains a 2-block lookahead queue.
  //
  // Flow:
  //   1. StartBlockPlanSession: Initialize and seed queue with 2 blocks
  //   2. FeedBlockPlan: Feed next block when slot becomes available
  //   3. StopBlockPlanSession: Terminate execution
  //
  // The executor handles CT advancement, fence termination, and lookahead
  // exhaustion automatically. Core only needs to feed blocks just-in-time.
  // ==========================================================================

  // StartBlockPlanSession initializes BlockPlan mode and seeds the 2-block queue.
  // Must provide exactly 2 contiguous blocks (block_a.end == block_b.start).
  // Stream attachment must already be done via AttachStream.
  rpc StartBlockPlanSession(StartBlockPlanSessionRequest) returns (StartBlockPlanSessionResponse);

  // FeedBlockPlan adds the next block to the queue.
  // Call when notified that a slot is available (after block completion).
  // Block must be contiguous with the pending block's end time.
  rpc FeedBlockPlan(FeedBlockPlanRequest) returns (FeedBlockPlanResponse);

  // StopBlockPlanSession terminates execution immediately.
  // Use when last viewer leaves or on error.
  rpc StopBlockPlanSession(StopBlockPlanSessionRequest) returns (StopBlockPlanSessionResponse);

  // SubscribeBlockEvents returns a stream of block lifecycle events.
  // Core subscribes after StartBlockPlanSession to receive BlockCompleted events.
  // This enables boundary-driven just-in-time feeding without polling.
  // Stream ends when session ends or is stopped.
  rpc SubscribeBlockEvents(SubscribeBlockEventsRequest) returns (stream BlockEvent);
}

// StartChannelRequest provides the context required to initialize a playout channel.
message StartChannelRequest {
  int32 channel_id = 1;      // Unique identifier for the target channel.
  string plan_handle = 2;    // Reference to the schedule plan that should begin playback.
  int32 port = 3;            // Local UDP/RTP port where the engine should output media.

  // Canonical per-channel program signal format.
  // JSON object; schema defined by PlayoutInstanceAndProgramFormatContract.md.
  // Required: defines video (width, height, frame_rate) and audio (sample_rate, channels).
  string program_format_json = 10;
}

// StartChannelResponse reports success or failure of the start operation.
message StartChannelResponse {
  bool success = 1;          // Indicates whether the channel started successfully.
  string message = 2;        // Optional diagnostic or error detail.
}

// UpdatePlanRequest identifies the channel and new plan to activate mid-stream.
message UpdatePlanRequest {
  int32 channel_id = 1;      // Target channel currently active on the engine.
  string plan_handle = 2;    // New plan to swap in for continued playback.
}

// UpdatePlanResponse indicates the result of applying the new plan.
message UpdatePlanResponse {
  bool success = 1;          // True if the plan update was accepted.
  string message = 2;        // Optional human-readable status message.
}

// StopChannelRequest identifies which channel to shut down.
message StopChannelRequest {
  int32 channel_id = 1;      // Channel identifier corresponding to the running instance.
}

// StopChannelResponse reports the outcome of the shutdown attempt.
message StopChannelResponse {
  bool success = 1;          // True if the channel stopped without error.
  string message = 2;        // Optional detail about the stop operation.
}

// ApiVersionRequest is intentionally empty; reserved for future handshake metadata.
message ApiVersionRequest {}

// ApiVersion communicates the protocol version supported by the engine.
message ApiVersion {
  string version = 1;        // Semantic version string of the playout control API.
}

// LoadPreviewRequest carries the next PlayoutSegment into the preview slot.
// Frame-indexed execution (INV-FRAME-001/002/003):
//   - start_frame: First frame index within asset (0-based). Air seeks to this frame.
//   - frame_count: Exact number of frames to play. Air stops after this count.
//   - fps_numerator/fps_denominator: Frame rate as rational (e.g. 30000/1001 = 29.97fps).
// SwitchToLive remains unchanged (no segment payload).
// INVARIANT: Core MUST provide frame-indexed fields. Air rejects requests without them.
message LoadPreviewRequest {
  int32 channel_id = 1;           // Target channel.
  string asset_path = 2;          // Fully-qualified media file path.
  int64 start_frame = 3;          // First frame index within asset (0-based). INV-FRAME-001.
  int64 frame_count = 4;          // Exact number of frames to play. INV-FRAME-002.
  int32 fps_numerator = 5;        // Frame rate numerator (e.g. 30000 for 29.97fps).
  int32 fps_denominator = 6;      // Frame rate denominator (e.g. 1001 for 29.97fps).
}

// LoadPreviewResponse reports the result of loading the preview asset.
message LoadPreviewResponse {
  bool success = 1;
  string message = 2;
  bool shadow_decode_started = 3;  // True if producer entered shadow mode.
  ResultCode result_code = 4;      // Phase 8: Typed result for Core to distinguish states
}

// SwitchToLiveRequest identifies the channel to switch from preview to live.
// P11C-001: INV-BOUNDARY-DECLARED-001 — Core declares target boundary time.
// P11D-012: INV-LEADTIME-MEASUREMENT-001 — issued_at_time_ms for lead-time evaluation.
message SwitchToLiveRequest {
  int32 channel_id = 1;     // Target channel.
  int64 target_boundary_time_ms = 2;  // Wall-clock ms when switch should occur (0 = immediate/legacy)
  int64 issued_at_time_ms = 3;  // Wall-clock ms when Core issued this request (for lead-time evaluation)
}

// SwitchToLiveResponse reports the result of the switch operation.
// P11B-001: INV-BOUNDARY-TOLERANCE-001 observability — completion time for delta measurement.
// P11D-004: violation_reason when result_code is PROTOCOL_VIOLATION.
message SwitchToLiveResponse {
  bool success = 1;
  string message = 2;
  // Optional: engine may report continuity details for debugging.
  bool pts_contiguous = 3;
  uint64 live_start_pts = 4;
  ResultCode result_code = 5;      // Phase 8: Typed result for Core to distinguish states
  int64 switch_completion_time_ms = 6;  // Wall-clock ms when switch actually completed
  string violation_reason = 7;     // P11D-004: Populated when result_code is PROTOCOL_VIOLATION
}

// Phase 8: Typed result codes for control operations
// Allows Core to distinguish between transient states and errors.
enum ResultCode {
  RESULT_CODE_UNSPECIFIED = 0;        // Default/unknown
  RESULT_CODE_OK = 1;                 // Operation succeeded
  RESULT_CODE_NOT_READY = 2;          // Transient: switch armed, awaiting readiness (don't panic, don't retry aggressively)
  RESULT_CODE_REJECTED_BUSY = 3;      // Operation forbidden in current state (e.g., LoadPreview while switch armed)
  RESULT_CODE_PROTOCOL_VIOLATION = 4; // Caller violated the protocol (e.g., SwitchToLive without LoadPreview)
  RESULT_CODE_FAILED = 5;             // Real error: operation failed permanently
}

// Phase 8: stream transport (Python creates sink, Air connects and writes bytes)

enum StreamTransport {
  STREAM_TRANSPORT_UNSPECIFIED = 0;
  STREAM_TRANSPORT_UNIX_DOMAIN_SOCKET = 1;  // recommended on Linux
  STREAM_TRANSPORT_TCP_LOOPBACK = 2;        // optional fallback (127.0.0.1:port)
}

message AttachStreamRequest {
  int32 channel_id = 1;

  // Where Air should write its output bytes.
  StreamTransport transport = 2;

  // For UNIX_DOMAIN_SOCKET: filesystem path like "/tmp/retrovue/ch_1.sock"
  // For TCP_LOOPBACK: host:port like "127.0.0.1:15001"
  string endpoint = 3;

  // If true, replacing an existing attachment is allowed.
  // If false, attaching when already attached is an error.
  bool replace_existing = 4;
}

message AttachStreamResponse {
  bool success = 1;
  string message = 2;

  // Optional: what Air actually used (in case of normalization).
  StreamTransport negotiated_transport = 3;
  string negotiated_endpoint = 4;
}

message DetachStreamRequest {
  int32 channel_id = 1;

  // If true, stop writing immediately even if live producer running.
  // Otherwise, detach happens at next safe boundary (optional policy).
  bool force = 2;
}

message DetachStreamResponse {
  bool success = 1;
  string message = 2;
}

// ==========================================================================
// BlockPlan Mode Messages
// ==========================================================================

// BlockPlan represents a single block of scheduled content.
// Maps to the BlockPlan struct in pkg/air/include/retrovue/blockplan/BlockPlanTypes.hpp
message BlockPlan {
  string block_id = 1;           // Unique identifier (e.g., "BLOCK-2025-01-15-14:30")
  int32 channel_id = 2;          // Channel this block belongs to
  int64 start_utc_ms = 3;        // Block start time (UTC milliseconds since epoch)
  int64 end_utc_ms = 4;          // Block end time (UTC milliseconds since epoch)
  repeated BlockSegment segments = 5;  // Segments within this block
}

// SegmentType distinguishes planned segment roles.
// Default 0 = CONTENT — backward-compatible with existing messages.
enum SegmentType {
  SEGMENT_TYPE_CONTENT = 0;
  SEGMENT_TYPE_FILLER = 1;
  SEGMENT_TYPE_PAD = 2;
}

// BlockSegment represents a contiguous portion of an asset within a block.
// PAD segments have no asset_uri (planned silence/black at block tail).
message BlockSegment {
  int32 segment_index = 1;           // Index within block (0-based, must be contiguous)
  string asset_uri = 2;              // Asset file path (empty for PAD segments)
  int64 asset_start_offset_ms = 3;   // Offset within asset where segment starts
  int64 segment_duration_ms = 4;     // Duration of this segment
  SegmentType segment_type = 5;      // Segment role (default CONTENT)
}

// StartBlockPlanSessionRequest initializes BlockPlan mode with 2 seed blocks.
message StartBlockPlanSessionRequest {
  int32 channel_id = 1;
  BlockPlan block_a = 2;         // First block (executing)
  BlockPlan block_b = 3;         // Second block (pending)
  int64 join_utc_ms = 4;         // Join time for mid-block join (0 = block_a.start)

  // Program format for encoding (same as StartChannelRequest)
  string program_format_json = 10;
}

message StartBlockPlanSessionResponse {
  bool success = 1;
  string message = 2;
  BlockPlanResultCode result_code = 3;
}

// FeedBlockPlanRequest adds the next block to the queue.
message FeedBlockPlanRequest {
  int32 channel_id = 1;
  BlockPlan block = 2;           // Next block to feed
}

message FeedBlockPlanResponse {
  bool success = 1;
  string message = 2;
  BlockPlanResultCode result_code = 3;
  bool queue_full = 4;           // True if queue was already full (block not accepted)
}

// StopBlockPlanSessionRequest terminates BlockPlan execution.
message StopBlockPlanSessionRequest {
  int32 channel_id = 1;
  string reason = 2;             // Reason for stopping (for logging)
}

message StopBlockPlanSessionResponse {
  bool success = 1;
  string message = 2;
  int64 final_ct_ms = 3;         // Final CT at termination
  int32 blocks_executed = 4;     // Total blocks completed
}

// Result codes for BlockPlan operations
enum BlockPlanResultCode {
  BLOCKPLAN_RESULT_UNSPECIFIED = 0;
  BLOCKPLAN_RESULT_OK = 1;
  BLOCKPLAN_RESULT_INVALID_BLOCK = 2;       // Block failed validation
  BLOCKPLAN_RESULT_NOT_CONTIGUOUS = 3;      // Block start != previous end
  BLOCKPLAN_RESULT_QUEUE_FULL = 4;          // Queue already has 2 blocks
  BLOCKPLAN_RESULT_NO_SESSION = 5;          // No active BlockPlan session
  BLOCKPLAN_RESULT_ALREADY_ACTIVE = 6;      // Session already running
  BLOCKPLAN_RESULT_STREAM_NOT_ATTACHED = 7; // Must AttachStream first
}

// ==========================================================================
// Block Event Streaming (boundary-driven feeding)
// ==========================================================================

// SubscribeBlockEventsRequest identifies the channel to subscribe to.
message SubscribeBlockEventsRequest {
  int32 channel_id = 1;
}

// BlockEvent represents a lifecycle event from the BlockPlan executor.
// AIR reports facts; Core decides whether to act.
message BlockEvent {
  int32 channel_id = 1;

  oneof event {
    BlockCompleted block_completed = 10;
    SessionEnded session_ended = 11;
  }
}

// BlockCompleted is emitted once per block, after the block fence is reached.
// Core uses this to know when to feed the next block.
// Does NOT include segment data. Does NOT request action.
message BlockCompleted {
  string block_id = 1;              // ID of the completed block
  int64 block_start_utc_ms = 2;     // Block start time (for correlation)
  int64 block_end_utc_ms = 3;       // Block end time (fence)
  int64 final_ct_ms = 4;            // Actual CT at completion (may exceed fence slightly)
  int32 blocks_executed_total = 5;  // Running count of blocks executed this session
}

// SessionEnded is emitted when the BlockPlan session terminates.
// Reason indicates why: lookahead_exhausted, stopped, error.
message SessionEnded {
  string reason = 1;                // "lookahead_exhausted", "stopped", "error"
  int64 final_ct_ms = 2;            // Final CT at termination
  int32 blocks_executed_total = 3;  // Total blocks completed
}
