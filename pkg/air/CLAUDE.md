You are working on AIR.

AIR is a C++ runtime playout engine for the Retro IPTV Simulation Project.
AIR enforces real-time execution correctness for a single active channel playout session.
AIR does not own schedules, EPG, channels, or editorial intent — those belong to Core.

────────────────────────
HOW TO COMPILE AIR (MANDATORY)
────────────────────────
Use this method only. Do not use other build directories, other cmake invocations, or IDE-generated builds.

Prerequisites:
- vcpkg installed; VCPKG_ROOT set (e.g. export VCPKG_ROOT=/path/to/vcpkg).
- vcpkg packages installed: run from repo root:
    sh pkg/air/INSTALL_VCPKG_PACKAGES.sh
  or: cd $VCPKG_ROOT && ./vcpkg install grpc gtest ffmpeg --triplet x64-linux

Configure (from repo root):
  cmake -S pkg/air -B pkg/air/build \
    -DCMAKE_TOOLCHAIN_FILE="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake" \
    -DCMAKE_BUILD_TYPE=RelWithDebInfo

Build:
  cmake --build pkg/air/build -j$(nproc)

Run tests:
  ctest --test-dir pkg/air/build --output-on-failure

Verifying builds (IMPORTANT):
- CMake incremental builds may not detect all changes. Always verify.
- After editing a source file, check that the object file was actually rebuilt:
    # Before build - note the timestamp
    ls -la pkg/air/build/CMakeFiles/retrovue_air.dir/src/producers/file/FileProducer.cpp.o
    # Build
    cmake --build pkg/air/build -j$(nproc)
    # After build - timestamp MUST have changed
    ls -la pkg/air/build/CMakeFiles/retrovue_air.dir/src/producers/file/FileProducer.cpp.o
- If the object file timestamp didn't change, force recompilation:
    touch pkg/air/src/producers/file/FileProducer.cpp
    cmake --build pkg/air/build -j$(nproc)
- For a full clean rebuild of a specific target:
    rm pkg/air/build/retrovue_air
    cmake --build pkg/air/build -j$(nproc)
- Do NOT assume the build worked without verifying timestamps changed.

Build directory:
- The build directory MUST be pkg/air/build.
- Do NOT use: build/ at repo root, pkg/air/out/, pkg/air/build-asan, or any other path.
- Do NOT run cmake from inside pkg/air/build; always use -S pkg/air -B pkg/air/build from repo root (or -S . -B build from pkg/air).

Output binary:
- The binary MUST be pkg/air/build/retrovue_air.
- Core spawns this binary when running `retrovue start`.
- Do NOT build or use binaries from any other location.

Logs:
- AIR writes logs to pkg/air/logs/<channelname>-air.log (e.g., pkg/air/logs/cheers-24-7-air.log).
- When debugging, always check this log file for the channel being tested.

Proto (if you change protos/playout.proto):
- From repo root: sh scripts/air/generate_proto.sh
- Python stubs go to pkg/core; C++ is generated by this project’s CMake.

────────────────────────
BOUNDARIES
────────────────────────
AIR IS responsible for:
- Runtime execution correctness
- Timing, buffering, and pacing
- Producer switching (preview ↔ live)
- Encoding, muxing, and output
- gRPC control surface
- Telemetry and metrics

AIR is NOT responsible for:
- Scheduling or EPG
- Multi-channel orchestration
- Editorial decisions
- Persistence of business truth
- As-run logging

────────────────────────
MENTAL MODEL
────────────────────────
One active PlayoutInstance at a time.

Signal flow:
Producer
 → InputBus / ProducerBus (LIVE or PREVIEW)
 → FrameRingBuffer
 → ProgramOutput
 → OutputBus
 → OutputSink (MPEG-TS)

Execution is driven by MasterClock + TimingLoop.

────────────────────────
FIRST-CLASS COMPONENTS
────────────────────────
Root:
- PlayoutEngine (owns one active session)
- PlayoutControl (explicit state machine)
- PlayoutInterface (gRPC adapter)

Session:
- PlayoutInstance
  - channel_id (external correlation only)
  - plan_handle
  - ProgramFormat (immutable per session)

Producers:
- IProducer
- FileProducer (FFmpeg decode, segment offsets)
- ProgrammaticProducer (synthetic/test)

Input:
- InputBus / ProducerBus
  - LIVE + PREVIEW
  - Atomic switching via PlayoutControl
  - Not a buffer

Buffer / Output:
- FrameRingBuffer
- ProgramOutput
- OutputBus
- IOutputSink
- MpegTSOutputSink

Timing:
- MasterClock (single time authority)
- TimingLoop (pacing + scheduling)

Telemetry:
- MetricsExporter
- MetricsHTTPServer (/metrics)

────────────────────────
gRPC SURFACE (CANONICAL)
────────────────────────
Source of truth: protos/playout.proto

Service: PlayoutControl

RPCs:
- StartChannel
- StopChannel
- UpdatePlan
- LoadPreview
- SwitchToLive
- AttachStream
- DetachStream
- GetVersion

gRPC is internal only.

────────────────────────
SESSION INVARIANTS
────────────────────────
- At most one active PlayoutInstance
- channel_id is correlation only
- ProgramFormat fixed for session lifetime
- InputBus switching is atomic
- PTS continuity preserved across preview → live
- Output attachment obeys PlayoutControl states

────────────────────────
CHANGE DISCIPLINE
────────────────────────
When asked “add X to AIR”:
1) Confirm X belongs to runtime execution.
2) Identify affected first-class components.
3) Preserve all invariants.
4) Update contracts/docs before behavior changes.
5) Do NOT introduce Core concepts.

────────────────────────
DOCUMENTATION RULES
────────────────────────
- Laws live only in docs/contracts/laws/. Do not restate or redefine laws elsewhere; reference the canonical document.
- Invariants must have IDs. Every codified invariant has a stable ID (e.g. INV-P8-001); see docs/contracts/INVARIANTS-INDEX.md.
- Phase documents are coordination contracts, not laws. They refine Layer 0 laws; they do not override them.
- Developer and overview docs are non-authoritative. They inform and explain; they do not define required behavior.

────────────────────────
INCIDENT ANALYSIS (CONTRACTS-FIRST)
────────────────────────
When analyzing runtime logs or incidents, ALWAYS use the contracts-first, logs-as-evidence methodology:

1. IDENTIFY CONTRACT VIOLATIONS FIRST
   - Scan for INV-* patterns (violations are the primary signal)
   - Categorize by invariant ID (INV-P8-*, INV-P9-*, INV-P10-*, etc.)
   - Count occurrences and extract parameters
   - These are the "what went wrong" — not symptoms, but contract breaches

2. RECONSTRUCT TIMELINE
   - Build a chronological sequence of events from log timestamps
   - Mark the boundary/trigger point (e.g., segment switch, EOF, etc.)
   - Identify what happened BEFORE vs AFTER the expected event
   - Calculate actual vs expected timing deltas

3. FORM HYPOTHESES (NOT CONCLUSIONS)
   - Start from the violation and work backwards
   - Identify the component that violated the contract
   - Find the upstream event that MIGHT have caused the component to fail
   - Form hypotheses about causation — do NOT assert "root cause"

   CRITICAL: Incident analysis may only assert:
   - **Observed facts** (direct quotes from logs, with timestamps)
   - **Hypotheses** (explicitly labeled as such)
   - **Tests** that would falsify each hypothesis

   "Root cause" is ONLY allowed after a hypothesis survives a falsification test.

   Example of WRONG analysis:
     "The audio queue filled up, which blocked video production. Root cause: shared buffers."

   Example of CORRECT analysis:
     "OBSERVED: Audio queue at capacity (queue_depth=180/180)
      OBSERVED: Encoder reports vq=0, aq=0
      HYPOTHESIS: Audio backpressure blocks the decode thread, preventing video production
      TEST: Check if FileProducer decode loop is single-threaded for audio+video
      TEST: Add log to confirm which producer instance is blocking"

4. CATEGORIZE LOG LINES
   | Category | Definition | Action |
   |----------|------------|--------|
   | Contract Proof | INV-* logs showing compliance | KEEP |
   | Contract Violation | INV-* VIOLATION logs | KEEP (critical) |
   | Phase/State Transition | State machine changes | KEEP |
   | Progress/Debug | DBG-*, counters, heartbeats | EVALUATE for noise |

5. PRODUCE ACTIONABLE OUTPUT
   - Observed facts (with log evidence)
   - Hypotheses (explicitly labeled, ranked by likelihood)
   - Falsification tests for each hypothesis
   - ONLY after testing: Root cause statement (one sentence)
   - Recommendations with priority (P0/P1/P2)
   - Log noise reduction opportunities (RATE-LIMIT, DELETE, GUARD)

6. LOG NOISE ACTIONS
   | Action | When to use |
   |--------|-------------|
   | DELETE | Log provides no diagnostic value |
   | DEMOTE | Useful for deep debugging only; hide by default |
   | RATE-LIMIT | Valuable but fires too often (e.g., 1/sec max) |
   | GUARD | Only emit when approaching violation threshold |

Example violation categories:
- INV-P8-*: Phase 8 (switching, timeline, segment ownership)
- INV-P9-*: Phase 9 (sink liveness, TS emission, boot liveness)
- INV-P10-*: Phase 10 (audio-video gate, PCR pacing, scaling)
- INV-SEGMENT-*: Segment content and frame count invariants
- INV-DECODE-*: Decode rate and producer health

────────────────────────
CONTRACTS-FIRST AUDITING
────────────────────────
When auditing logs, analyzing behavior, or reviewing code changes, validate against the Canonical Rule Ledger:

Source of truth: docs/contracts/CANONICAL_RULE_LEDGER.md

AUDIT PRINCIPLES:
- Logs exist ONLY for: (1) Contract proof, (2) Contract violation, (3) Phase/state transitions
- Any log not serving one of those purposes is NOISE
- If code enforces behavior not in the ledger, the code is wrong
- If the ledger lists a rule code doesn't enforce, the code is wrong

AUDIT WORKFLOW:
1. Read the Canonical Rule Ledger first
2. Classify each log/behavior against ledger entries
3. Identify gaps (behaviors without contracts, contracts without enforcement)
4. Output execution-ready directives

AUDIT OUTPUT FORMAT (by subsystem):
```
Subsystem: [component name]
- DELETE: [exact log pattern]
- GUARD: [exact log pattern] → [condition when to emit]
- DEMOTE: [exact log pattern] → TRACE
- RATE-LIMIT: [exact log pattern] → [max frequency]
- CONSOLIDATE: [patterns] → [single canonical log line]
- KEEP: [pattern] (ledger rule ID)
```

CONSTRAINTS:
- Do NOT propose architecture changes during audit
- Do NOT write code during audit (that comes later)
- Output must be suitable for direct execution

────────────────────────
INVARIANT DISCOVERY & PROMOTION
────────────────────────
When incidents reveal missing contracts or behaviors that SHOULD be invariants:

1. IDENTIFY CANDIDATE INVARIANTS
   From incident analysis, look for:
   - Implicit assumptions that were violated
   - Timing requirements that aren't codified
   - Resource limits that caused failures
   - Cross-component contracts that aren't documented

2. DRAFT INVARIANT PROPOSAL
   For each candidate:
   ```
   | Field | Value |
   |-------|-------|
   | Proposed ID | INV-[PHASE]-[NAME]-NNN |
   | Classification | CONTRACT |
   | Owner | [Component] |
   | Enforcement | [Phase: P8/P9/P10/RUNTIME/etc.] |
   | One-Line Definition | [Clear, testable statement] |
   | Derives From | [Parent LAW or CONTRACT if any] |
   | Evidence | [Incident that revealed need] |
   ```

3. PROMOTION WORKFLOW
   a. Add to "Proposed Invariants" section in CANONICAL_RULE_LEDGER.md
   b. Create implementation task for:
      - Code enforcement (if not present)
      - Test coverage
      - Log coverage (proof + violation)
   c. After implementation verified, promote to appropriate Layer

4. TASK CREATION FORMAT
   For each invariant requiring implementation:
   ```
   Task: Implement [INV-ID]
   Description: [One-line definition]
   Acceptance Criteria:
   - [ ] Code enforces invariant
   - [ ] Test exists proving compliance
   - [ ] Test exists proving violation detection
   - [ ] Log emitted on violation (if Log=Yes in ledger)
   - [ ] Ledger updated (Test=Yes, promoted from Proposed)
   ```

INVARIANT NAMING CONVENTIONS:
- INV-P8-*: Phase 8 (timeline, switching, segment)
- INV-P9-*: Phase 9 (output bootstrap, sink liveness)
- INV-P10-*: Phase 10 (steady-state, flow control)
- INV-SEGMENT-*: Content and frame invariants
- INV-DECODE-*: Decoder health
- INV-SINK-*: Output sink behavior
- INV-ENCODER-*: Encoding constraints
- LAW-*: Constitutional (rarely added)

PROMOTION CRITERIA:
- Invariant has clear, testable definition
- At least one incident or test case demonstrates need
- Owner component identified
- Does not duplicate existing rule (check Derivation Notes)
- Enforcement phase is unambiguous

ACKNOWLEDGEMENT:
Confirm understanding of AIR as a single-session C++ playout engine with explicit buses, strict timing control, and gRPC-defined boundaries.
Do not proceed until accepted.
