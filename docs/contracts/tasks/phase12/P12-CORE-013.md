Task ID: P12-CORE-013
Rule ID: INV-STARTUP-CONVERGENCE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager
Task Type: FIX
File(s) to Modify: pkg/core/src/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P12-CORE-011

Instructions:
- Add convergence timeout check to tick() or boundary evaluation
- If convergence deadline expires before first successful boundary: FAILED_TERMINAL
- Timeout is a safety net, not a normal operating condition

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

Rule Definition (INV-STARTUP-CONVERGENCE-001):
The session MUST converge within MAX_STARTUP_CONVERGENCE_WINDOW (120 seconds). Failure to converge transitions the session to FAILED_TERMINAL.

Implementation:

1. In `tick()` or at boundary evaluation time, check convergence timeout:
   ```python
   def _check_convergence_timeout(self) -> bool:
       """Returns True if session should continue, False if timed out."""
       if self._converged:
           return True  # Already converged, no timeout concern

       if self._convergence_deadline is None:
           return True  # No deadline set (shouldn't happen)

       now = datetime.now(timezone.utc)
       if now >= self._convergence_deadline:
           self._logger.error(
               "INV-STARTUP-CONVERGENCE-001 FATAL: Convergence timeout expired "
               "after %s without successful boundary transition",
               MAX_STARTUP_CONVERGENCE_WINDOW
           )
           self._pending_fatal = SchedulingError(
               "Startup convergence timeout: no boundary executed within window"
           )
           self._transition_boundary_state(BoundaryState.FAILED_TERMINAL)
           return False

       return True
   ```

2. Call from `tick()`:
   ```python
   async def tick(self) -> None:
       # ... existing checks ...

       # Check convergence timeout (before boundary work)
       if not self._check_convergence_timeout():
           return  # Session is dead

       # ... rest of tick ...
   ```

3. Alternatively, check at boundary evaluation time:
   ```python
   def _evaluate_next_boundary(self):
       if not self._check_convergence_timeout():
           return  # Session is dead

       # ... boundary evaluation ...
   ```

4. Log format:
   ```
   INV-STARTUP-CONVERGENCE-001 FATAL: Convergence timeout expired after 0:02:00 without successful boundary transition
   ```

Constraints:
- MAX_STARTUP_CONVERGENCE_WINDOW is an upper bound to guarantee eventual correctness, not a target duration
- Normal operation should converge much faster (first or second boundary)
- Timeout indicates a problem with schedule content, not normal operation
- After timeout, session enters FAILED_TERMINAL (triggers deferred teardown if pending)

Rationale:
Convergence cannot be indefinite. If the session cannot execute a clean boundary within 2 minutes, something is fundamentally wrong (schedule gaps, persistent infeasibility). The timeout guarantees the session eventually fails rather than running forever in degraded mode.

Done Criteria:
Convergence timeout checked in tick() or boundary evaluation; FAILED_TERMINAL on timeout expiry; logged as FATAL; `_pending_fatal` set with reason.

---

## Completion

- **Date:** 2026-02-02
- **Implementation:** `channel_manager.py`
  - Added `_check_convergence_timeout() -> bool`: if `_converged` or `_convergence_deadline is None` returns True. Else if `now >= _convergence_deadline`: log `INV-STARTUP-CONVERGENCE-001 FATAL: Convergence timeout expired after MAX_STARTUP_CONVERGENCE_WINDOW without successful boundary transition`; set `_pending_fatal = SchedulingError(...)`; `_transition_boundary_state(FAILED_TERMINAL)`; return False. Otherwise return True.
  - In `tick()`, after segment_end/now and before boundary feasibility/skip: call `_check_convergence_timeout()`; if not True, return.
- **Tests:** Runtime suite 131 passed. Contract test P12-TEST-011 pending.
