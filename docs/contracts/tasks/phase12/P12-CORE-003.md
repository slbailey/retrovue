Task ID: P12-CORE-003
Rule ID: INV-TEARDOWN-STABLE-STATE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager
Task Type: FIX
File(s) to Modify: pkg/core/src/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P12-CORE-002

Instructions:
- Modify `_transition_boundary_state()` to check for pending teardown
- When entering a stable state with teardown pending, trigger deferred teardown
- Add `_execute_deferred_teardown()` helper method
- Ensure no recursion between teardown execution and state transitions

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

Rule Definition (INV-TEARDOWN-STABLE-STATE-001):
Teardown due to viewer inactivity MUST be deferred until `_boundary_state` is stable.

Implementation:

1. At end of `_transition_boundary_state()`, after state is updated:
   - Check: `if self._teardown_pending and new_state in _STABLE_STATES`
   - If true: log info "deferred teardown now permitted", call `_execute_deferred_teardown()`

2. Add `_execute_deferred_teardown(self) -> None`:
   - Log: `"INV-TEARDOWN-STABLE-STATE-001: Executing deferred teardown (was_state=%s, reason=%s)"`
   - Clear `_teardown_pending`, `_teardown_deadline`, `_teardown_reason`
   - Signal to ProgramDirector that teardown may proceed (callback or flag)

3. Coordination with ProgramDirector:
   - Option A: ChannelManager sets a `_teardown_ready` flag that ProgramDirector polls
   - Option B: ChannelManager calls a registered callback
   - Option C: ChannelManager directly calls its own stop logic
   - Choose simplest option that doesn't create circular dependencies

Constraints:
- MUST NOT recurse: `_execute_deferred_teardown()` should not call `_request_teardown()`
- MUST handle transition to `FAILED_TERMINAL` (also a stable state)
- MUST clear pending state before executing teardown (prevent double-execution)

Edge Cases:
- Transition from `SWITCH_ISSUED` to `LIVE`: normal deferred teardown path
- Transition from `SWITCH_ISSUED` to `FAILED_TERMINAL`: also triggers deferred teardown
- Illegal transition forcing `FAILED_TERMINAL`: deferred teardown still executes

Done Criteria:
Deferred teardown executes exactly once when stable state is reached; no double-execution; works for both `LIVE` and `FAILED_TERMINAL` entry.

---

## Completion

**Completed:** 2025-02-02

**Changes (pkg/core/src/retrovue/runtime/channel_manager.py):**
- Added `_deferred_teardown_triggered: bool = False` in `__init__`; cleared in `stop_channel()`.
- At end of `_transition_boundary_state()` (legal path): if `_teardown_pending and new_state in _STABLE_STATES`, log and call `_execute_deferred_teardown()`.
- On illegal transition to `FAILED_TERMINAL`: before return, if `_teardown_pending`, call `_execute_deferred_teardown()`.
- Added `_execute_deferred_teardown()`: log "Executing deferred teardown (was_state=..., reason=...)", clear pending/deadline/reason, set `_deferred_teardown_triggered = True`.
- Added `deferred_teardown_triggered()` for ProgramDirector to poll (P12-CORE-006).
- No recursion: `_execute_deferred_teardown()` does not call `_request_teardown()` or state transitions.
