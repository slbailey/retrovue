Task ID: P8-INT-002
Rule ID: INV-P8-CONTENT-DEFICIT-FILL-001
Governing Law: LAW-OUTPUT-LIVENESS
Subsystem: Core (HTTP layer), AIR (MpegTSOutputSink)
Task Type: INTEGRATION TEST
File(s) to Modify: pkg/core/tests/integration/test_http_resilience.py
Owner: Core + AIR
Blocked By: P8-INT-001

Instructions:
- Add integration test: HTTP connection survives content deficit
- Verify HTTP 200 maintained during deficit
- Verify TS bytes flow continuously
- Verify no false viewer disconnect

---

Governing Principle (LAW-OUTPUT-LIVENESS):
> ProgramOutput never blocks; if no content → deterministic pad (black + silence).

Rule Definition (INV-P8-CONTENT-DEFICIT-FILL-001):
Output liveness and TS cadence are preserved; the mux never stalls. HTTP connections must survive content deficit.

Test Scenario:

1. **Setup:**
   - Start channel with viewer connected via HTTP
   - Segment with content deficit (short content)
   - HTTP client monitoring response

2. **Execution:**
   - Viewer connects, receives TS stream
   - Content plays normally
   - Decoder EOF (content shorter than planned)
   - Content deficit fill activates
   - Pad frames emit
   - Switch to next segment

3. **Verification Points:**
   - HTTP response status: 200 OK throughout
   - No TCP RST or FIN during deficit
   - TS bytes received continuously (no timeout)
   - Viewer not disconnected

4. **Timing Requirements:**
   - HTTP read timeout typically 30s
   - Content deficit duration < 30s (bounded by grace timeout)
   - TS packets every ~20-40ms
   - No gap > 100ms in TS delivery

5. **Observable Proof:**
   - HTTP connection open throughout test
   - Bytes received counter increases during deficit
   - No viewer disconnect event in Core
   - ProgramDirector viewer count unchanged

6. **Failure Reproduction:**
   Without this fix:
   - EOF → buffer empty → no TS packets → HTTP timeout → connection close → viewer disconnect → teardown cascade
   This test verifies that failure mode is prevented.

7. **Python Test Outline:**
   ```python
   def test_http_connection_survives_content_deficit():
       # Start channel with short content
       channel_id = start_channel_with_short_content()

       # Connect viewer
       response = requests.get(f"{BASE_URL}/stream/{channel_id}", stream=True)
       assert response.status_code == 200

       # Read bytes during content and deficit
       bytes_received = 0
       last_byte_time = time.time()
       deadline = time.time() + 15  # Enough for content + deficit + switch

       for chunk in response.iter_content(chunk_size=1024):
           bytes_received += len(chunk)
           last_byte_time = time.time()
           if time.time() > deadline:
               break

       # Verify continuous flow
       assert bytes_received > MIN_EXPECTED_BYTES
       # Verify no long gaps (would have raised timeout)
   ```

Done Criteria:
HTTP 200 maintained; TS bytes flow during deficit; no false viewer disconnect; connection survives.
