Task ID: P11F-009
Rule ID: INV-SWITCH-ISSUANCE-TERMINAL-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager
Task Type: TEST
File(s) to Modify: pkg/core/tests/test_channel_manager_terminal.py
Owner: Core
Blocked By: P11F-003

Instructions:
- Add contract tests for terminal exception handling
- Verify exceptions transition to FAILED_TERMINAL
- Verify no retry/re-arm after exception
- Verify tick cannot retry failed boundary

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

Rule Definition (INV-SWITCH-ISSUANCE-TERMINAL-001):
Exception during SwitchToLive issuance MUST transition boundary to FAILED_TERMINAL state. No retry, no re-arm, no tick-based reissuance.

Test Cases:

1. Test RPC exception transitions to FAILED_TERMINAL:
   ```python
   async def test_rpc_exception_is_terminal(self):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: RPC exception forces terminal state."""
       manager = self._create_manager()
       boundary_time = datetime.now(timezone.utc) + timedelta(seconds=10)

       # Mock RPC to raise exception
       async def failing_rpc(*args):
           raise ConnectionError("AIR unavailable")
       manager._issue_switch_to_live_impl = failing_rpc

       manager._boundary_state = BoundaryState.SWITCH_SCHEDULED
       await manager._on_switch_issue_deadline(boundary_time)

       assert manager._boundary_state == BoundaryState.FAILED_TERMINAL
       assert manager._pending_fatal is not None
       assert "AIR unavailable" in str(manager._pending_fatal)
   ```

2. Test timer is NOT re-armed after exception:
   ```python
   async def test_no_rearm_after_exception(self):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: Timer is NOT re-registered on failure."""
       manager = self._create_manager()
       boundary_time = datetime.now(timezone.utc) + timedelta(seconds=10)

       # Mock RPC to raise exception
       async def failing_rpc(*args):
           raise RuntimeError("Timeout")
       manager._issue_switch_to_live_impl = failing_rpc

       # Clear any existing handle
       manager._switch_handle = None

       manager._boundary_state = BoundaryState.SWITCH_SCHEDULED
       await manager._on_switch_issue_deadline(boundary_time)

       # Handle should still be None (not re-armed)
       assert manager._switch_handle is None
       assert manager._boundary_state == BoundaryState.FAILED_TERMINAL
   ```

3. Test tick cannot retry after terminal:
   ```python
   async def test_tick_cannot_retry_terminal(self):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: tick() cannot retry failed boundary."""
       manager = self._create_manager()

       # Force into terminal state
       manager._boundary_state = BoundaryState.FAILED_TERMINAL
       manager._pending_fatal = SchedulingError("Previous failure")

       # Track if any switch logic is invoked
       switch_attempted = False
       original = manager._schedule_switch_issuance
       def mock_schedule(*args):
           nonlocal switch_attempted
           switch_attempted = True
           return original(*args)
       manager._schedule_switch_issuance = mock_schedule

       # Run tick multiple times
       for _ in range(5):
           await manager.tick()

       # No retry should have been attempted
       assert switch_attempted is False
       assert manager._boundary_state == BoundaryState.FAILED_TERMINAL
   ```

4. Test various exception types all terminal:
   ```python
   @pytest.mark.parametrize("exception", [
       ConnectionError("Connection refused"),
       TimeoutError("RPC timeout"),
       ValueError("Invalid boundary"),
       RuntimeError("Unknown error"),
   ])
   async def test_all_exceptions_are_terminal(self, exception):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: All exception types are terminal."""
       manager = self._create_manager()
       boundary_time = datetime.now(timezone.utc) + timedelta(seconds=10)

       async def failing_rpc(*args):
           raise exception
       manager._issue_switch_to_live_impl = failing_rpc

       manager._boundary_state = BoundaryState.SWITCH_SCHEDULED
       await manager._on_switch_issue_deadline(boundary_time)

       assert manager._boundary_state == BoundaryState.FAILED_TERMINAL
   ```

5. Test pending_fatal contains diagnostic info:
   ```python
   async def test_pending_fatal_has_diagnostics(self):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: pending_fatal includes boundary and error."""
       manager = self._create_manager()
       boundary_time = datetime(2025, 1, 15, 12, 0, 0, tzinfo=timezone.utc)

       async def failing_rpc(*args):
           raise ConnectionError("specific_error_message")
       manager._issue_switch_to_live_impl = failing_rpc

       manager._boundary_state = BoundaryState.SWITCH_SCHEDULED
       await manager._on_switch_issue_deadline(boundary_time)

       error_str = str(manager._pending_fatal)
       # Should contain boundary info
       assert "2025-01-15" in error_str or "boundary" in error_str.lower()
       # Should contain original error
       assert "specific_error_message" in error_str
   ```

6. Test no catch-and-continue patterns:
   ```python
   async def test_exception_not_swallowed(self):
       """INV-SWITCH-ISSUANCE-TERMINAL-001: Exceptions are not silently swallowed."""
       manager = self._create_manager()
       boundary_time = datetime.now(timezone.utc) + timedelta(seconds=10)

       async def failing_rpc(*args):
           raise RuntimeError("Must not be swallowed")
       manager._issue_switch_to_live_impl = failing_rpc

       manager._boundary_state = BoundaryState.SWITCH_SCHEDULED

       # State before
       assert manager._pending_fatal is None

       await manager._on_switch_issue_deadline(boundary_time)

       # Exception was captured, not swallowed
       assert manager._pending_fatal is not None
       # And state is terminal, not still pending
       assert manager._boundary_state != BoundaryState.SWITCH_SCHEDULED
       assert manager._boundary_state == BoundaryState.FAILED_TERMINAL
   ```

Done Criteria:
All exception types verified terminal; no retry/re-arm after failure; tick cannot retry; pending_fatal contains diagnostics; no catch-and-continue patterns remain.

---

## Completion Status

| Field | Value |
|-------|-------|
| **Status** | COMPLETE |
| **Completed** | 2026-02-02 |
| **Implementation** | pkg/core/tests/runtime/test_channel_manager_terminal.py: test_rpc_exception_is_terminal, test_no_rearm_after_exception, test_tick_cannot_retry_terminal, test_all_exceptions_are_terminal (parametrized), test_pending_fatal_has_diagnostics, test_exception_not_swallowed. FakeProducerWithSwitch with overridable switch_to_live. |
| **Tests** | 9 tests in test_channel_manager_terminal.py; 71 runtime tests pass. |
