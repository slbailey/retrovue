Task ID: P11D-003
Rule ID: INV-SWITCH-DEADLINE-AUTHORITATIVE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: PlayoutEngine
Task Type: FIX
File(s) to Modify: pkg/air/src/runtime/PlayoutEngine.cpp, pkg/air/src/output/SafetyRailEmitter.cpp
Owner: AIR
Blocked By: P11D-002

Instructions:
- If preview not ready at deadline, emit safety rail output (pad frames + silence)
- Log the violation for post-hoc analysis
- **Never block or delay the switch — clock wins, content catches up**

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

This task implements the consequence of the hierarchy: when clock fires but frames aren't ready, we emit safety rails (pad/silence) rather than delaying the clock. The clock NEVER waits for content.

Rule Definition (INV-SWITCH-DEADLINE-AUTHORITATIVE-001):
When `target_boundary_time_ms` is provided, AIR MUST execute the switch at that wall-clock time ± 1 frame; if not ready, AIR MUST use safety rails and log violation.

Implementation:

1. In DoSwitch, handle unready state:
   ```cpp
   void DoSwitch(int64_t channel_id) {
       auto* preview = GetPreviewProducer(channel_id);
       auto* live = GetLiveProducer(channel_id);

       if (!preview || !preview->HasFrameReady()) {
           // Not ready — use safety rails
           LOG_ERROR("[PlayoutEngine] INV-SWITCH-DEADLINE-AUTHORITATIVE-001 VIOLATION: "
                     "Switch executed at deadline but preview not ready. Using safety rails.");

           IncrementMetric("switch_deadline_not_ready_total");

           // Engage safety rail emitter instead of preview
           EngageSafetyRails(channel_id);
       } else {
           // Normal switch
           SwitchProducerToLive(channel_id);
       }
   }
   ```

2. Safety rail emitter behavior:
   ```cpp
   void EngageSafetyRails(int64_t channel_id) {
       // Video: emit pad frame (black, slate, or last good frame)
       video_emitter_.EmitPadFrame(channel_id);

       // Audio: emit silence samples at correct rate
       audio_emitter_.EmitSilence(channel_id);

       LOG_INFO("[PlayoutEngine] Safety rails engaged for channel %ld", channel_id);

       // Continue attempting to recover preview
       SchedulePreviewRecovery(channel_id);
   }
   ```

3. Recovery from safety rails:
   ```cpp
   void SchedulePreviewRecovery(int64_t channel_id) {
       // Check every frame period if preview became ready
       recovery_scheduler_.ScheduleRepeating(FramePeriodMs(), [this, channel_id]() {
           if (IsPreviewReady(channel_id)) {
               DisengageSafetyRails(channel_id);
               SwitchProducerToLive(channel_id);
               return false;  // Stop repeating
           }
           return true;  // Keep trying
       });
   }
   ```

Log Specification:

Violation detected:
```
[PlayoutEngine] INV-SWITCH-DEADLINE-AUTHORITATIVE-001 VIOLATION: Switch executed at deadline but preview not ready. Using safety rails.
```

Safety rails engaged:
```
[PlayoutEngine] Safety rails engaged for channel 1
```

Recovery:
```
[PlayoutEngine] Safety rails disengaged for channel 1, preview recovered
```

Metrics:
- `switch_deadline_not_ready_total` — counter of switches that hit deadline unready
- `safety_rail_duration_ms` — histogram of time spent in safety rail mode

Constraints:
- Safety rails MUST produce valid MPEG-TS (no output gaps)
- Recovery MUST happen seamlessly without viewer-visible glitch
- Violation MUST be logged for operational awareness

Done Criteria:
Switch at deadline with unready preview results in safety rail output, not blocked switch.
