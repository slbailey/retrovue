Task ID: P11D-008
Rule ID: INV-CONTROL-NO-POLL-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: Integration
Task Type: TEST
File(s) to Modify: pkg/air/tests/integration/PrefeedProtocolTests.cpp (new file)
Owner: Test
Blocked By: P11D-004

Instructions:
- Create contract test verifying late prefeed results in PROTOCOL_VIOLATION
- Test must verify Core does NOT retry after violation
- **Critical: Test validates that poll/retry pattern is forbidden**

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

This test validates the protocol consequence of the hierarchy: when Core declares a time it can't meet (late prefeed), AIR returns PROTOCOL_VIOLATION â€” not NOT_READY. NOT_READY implies "retry until ready" which inverts the hierarchy.

Rule Definition (INV-CONTROL-NO-POLL-001):
SwitchToLive MUST NOT return NOT_READY requiring Core to poll/retry. If prefeed timing was violated, return PROTOCOL_VIOLATION.

Test Scenario:
TEST_INV_CONTROL_NO_POLL_001_LatePrefeedReturnsProtocolViolation

- Given: SwitchToLive issued with target boundary less than MIN_PREFEED_LEAD_TIME in future
- When: AIR processes the request
- Then: Response status is PROTOCOL_VIOLATION (not NOT_READY)
- And: Response includes violation_reason
- And: Core does NOT retry

Test Implementation:

```cpp
class PrefeedProtocolTests : public ::testing::Test {
protected:
    void SetUp() override {
        master_clock_ = std::make_unique<MockMasterClock>();
        playout_engine_ = std::make_unique<PlayoutEngine>(master_clock_.get());
    }

    static constexpr int64_t kMinPrefeedLeadTimeMs = 5000;
    static constexpr int64_t channel_id_ = 1;
};

TEST_F(PrefeedProtocolTests, LatePrefeedReturnsProtocolViolation) {
    // Arrange: Target boundary is only 500ms in future (< MIN_PREFEED_LEAD_TIME)
    int64_t now_ms = master_clock_->NowMs();
    int64_t target_boundary_ms = now_ms + 500;  // Way too late

    // Act: Issue SwitchToLive with insufficient lead time
    SwitchToLiveRequest request;
    request.set_channel_id(channel_id_);
    request.set_target_boundary_time_ms(target_boundary_ms);

    SwitchToLiveResponse response;
    auto status = playout_engine_->SwitchToLive(request, &response);

    // Assert: Returns PROTOCOL_VIOLATION, not NOT_READY
    EXPECT_TRUE(status.ok());  // gRPC status is OK
    EXPECT_EQ(response.status(), SWITCH_STATUS_PROTOCOL_VIOLATION)
        << "INV-CONTROL-NO-POLL-001: Late prefeed must return PROTOCOL_VIOLATION, not NOT_READY";

    EXPECT_FALSE(response.violation_reason().empty())
        << "PROTOCOL_VIOLATION must include violation_reason";

    // Assert: Log shows violation
    EXPECT_TRUE(LogContains("INV-CONTROL-NO-POLL-001 VIOLATION"));
}

TEST_F(PrefeedProtocolTests, NotReadyNeverReturnedInDeadlineMode) {
    // Arrange: Preview not loaded (would trigger NOT_READY in legacy mode)
    // Target boundary is sufficiently in future
    int64_t now_ms = master_clock_->NowMs();
    int64_t target_boundary_ms = now_ms + 10000;  // Sufficient lead time

    // Do NOT load preview

    // Act: Issue SwitchToLive
    SwitchToLiveRequest request;
    request.set_channel_id(channel_id_);
    request.set_target_boundary_time_ms(target_boundary_ms);

    SwitchToLiveResponse response;
    auto status = playout_engine_->SwitchToLive(request, &response);

    // Assert: Does NOT return NOT_READY
    EXPECT_NE(response.status(), SWITCH_STATUS_NOT_READY)
        << "INV-CONTROL-NO-POLL-001: NOT_READY must not be returned in deadline-authoritative mode";

    // Switch should be accepted (AIR will use safety rails at deadline if needed)
    EXPECT_EQ(response.status(), SWITCH_STATUS_OK);
}

TEST_F(PrefeedProtocolTests, SufficientLeadTimeAccepted) {
    // Arrange: Load preview and set target boundary with sufficient lead time
    playout_engine_->LoadPreview(channel_id_, "test_plan");

    int64_t now_ms = master_clock_->NowMs();
    int64_t target_boundary_ms = now_ms + kMinPrefeedLeadTimeMs + 1000;  // Lead time + buffer

    // Act
    SwitchToLiveRequest request;
    request.set_channel_id(channel_id_);
    request.set_target_boundary_time_ms(target_boundary_ms);

    SwitchToLiveResponse response;
    auto status = playout_engine_->SwitchToLive(request, &response);

    // Assert: Accepted
    EXPECT_TRUE(status.ok());
    EXPECT_EQ(response.status(), SWITCH_STATUS_OK);
    EXPECT_EQ(response.switch_completion_time_ms(), target_boundary_ms);
}

TEST_F(PrefeedProtocolTests, CoreDoesNotRetryAfterViolation) {
    // This test verifies Core behavior (mock AIR, test Core)
    // Implemented in Python test suite

    // Pseudocode for Core test:
    // 1. Mock AIR to return PROTOCOL_VIOLATION
    // 2. Call channel_manager.switch_to_live()
    // 3. Assert: SwitchTimingError raised
    // 4. Assert: No retry attempts made
    // 5. Assert: Violation logged
}
```

Python Integration Test (Core side):

```python
# pkg/core/tests/integration/test_prefeed_protocol.py

class TestPrefeedProtocol:

    async def test_protocol_violation_raises_exception(self, mock_air_client):
        """Verify Core raises exception on PROTOCOL_VIOLATION, does not retry."""
        # Arrange: Mock AIR to return PROTOCOL_VIOLATION
        mock_air_client.switch_to_live.return_value = SwitchToLiveResponse(
            status=SwitchStatus.PROTOCOL_VIOLATION,
            violation_reason="Insufficient prefeed lead time"
        )

        channel_manager = ChannelManager(air_client=mock_air_client)

        # Act & Assert: Exception raised
        with pytest.raises(SwitchTimingError) as exc_info:
            await channel_manager.switch_to_live(channel_id=1, plan_handle="test")

        assert "Protocol violation" in str(exc_info.value)

        # Assert: Only one call made (no retry)
        assert mock_air_client.switch_to_live.call_count == 1

    async def test_not_ready_raises_protocol_error(self, mock_air_client):
        """Verify deprecated NOT_READY is treated as error."""
        mock_air_client.switch_to_live.return_value = SwitchToLiveResponse(
            status=SwitchStatus.NOT_READY
        )

        channel_manager = ChannelManager(air_client=mock_air_client)

        with pytest.raises(SwitchProtocolError):
            await channel_manager.switch_to_live(channel_id=1, plan_handle="test")

        # No retry
        assert mock_air_client.switch_to_live.call_count == 1
```

Assertions Required:
1. Late prefeed returns PROTOCOL_VIOLATION with reason
2. NOT_READY never returned in deadline-authoritative mode
3. Sufficient lead time results in OK status
4. Core raises exception on violation (no retry)

Done Criteria:
Contract tests prove late prefeed results in PROTOCOL_VIOLATION and Core does not retry.
