Task ID: P11D-011
Rule ID: INV-SWITCH-ISSUANCE-DEADLINE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager/Scheduler
Task Type: FIX
File(s) to Modify: pkg/core/src/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P11D-010
Blocks: P11D-006

Instructions:
- SwitchToLive issuance MUST be deadline-scheduled, not cadence-detected
- Issuance MUST occur no later than `boundary_time - MIN_PREFEED_LEAD_TIME`
- Remove tick-based switch detection; use event loop deadline primitive

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

If switch execution is deadline-authoritative, switch issuance must also be deadline-scheduled. Cadence-based detection reintroduces timing luck that deadline-authoritative semantics were designed to eliminate.

Rule Definition (INV-SWITCH-ISSUANCE-DEADLINE-001):

SwitchToLive issuance MUST be deadline-scheduled and issued no later than `boundary_time - MIN_PREFEED_LEAD_TIME`. Cadence-based detection, tick loops, and jitter padding are forbidden.

**Definition of "deadline-scheduled":** The issuance is registered once with the event loop as a timed callback or task at plan time; it is not discovered later by periodic checks.

Core MUST compute a single, deterministic issuance time for each boundary:

```
issue_at = boundary_time - MIN_PREFEED_LEAD_TIME
```

SwitchToLive MUST be issued no later than `issue_at`; issuing earlier is permitted. Late issuance (after `issue_at`) is a violation and MUST be treated as fatal.

**Derivation:**

| Parent Rule | Relationship |
|-------------|--------------|
| LAW-AUTHORITY-HIERARCHY | Clock authority is absolute; issuance timing derives from clock, not loop frequency |
| INV-SWITCH-DEADLINE-AUTHORITATIVE-001 | Execution is deadline-bound; issuance must be equally precise |
| INV-CONTROL-NO-POLL-001 | No poll/retry semantics; extends to issuance timing |

Root Cause Being Addressed:
Current implementation uses tick loops to detect `now >= switch_at`. This causes issuance timing to depend on loop frequency and scheduling jitter, reintroducing timing luck. A tick loop running at 1-second intervals introduces up to 1 second of jitter. Padding lead times to absorb jitter is forbidden.

Implementation:

1. Remove cadence-based switch detection from tick():
   ```python
   # REMOVE this pattern from tick():
   # if now >= self._switch_at:
   #     await self._issue_switch_to_live()
   ```

2. Schedule switch issuance at plan time using event loop primitive:
   ```python
   def _schedule_switch_issuance(self, boundary_time: datetime) -> None:
       """Register switch issuance with event loop at plan time."""
       issue_at = boundary_time - MIN_PREFEED_LEAD_TIME
       delay = (issue_at - datetime.now(timezone.utc)).total_seconds()

       # Register timed callback; event loop fires at deadline
       self._loop.call_later(delay, self._issue_switch_to_live_callback, boundary_time)
   ```

3. Call scheduling function when boundary is planned:
   ```python
   def _plan_boundary(self, boundary_time: datetime) -> None:
       # ... validate feasibility per P11D-009, P11D-010 ...

       # Schedule issuance as timed callback (not detected later)
       self._schedule_switch_issuance(boundary_time)
   ```

Constraints:
- Issuance MUST be registered once with event loop at plan time
- Issuance MUST NOT be discovered by periodic checks
- Cadence-based detection (`if now >= switch_at`) is forbidden
- Tick-jitter padding or lead-time inflation is forbidden
- Loop-frequency-dependent correctness is forbidden
- `asyncio.sleep(delay)` without underlying deadline primitive is forbidden
- Late issuance (after `issue_at`) is fatal
- Early issuance is permitted (increases lead time)

Non-Goals (Explicitly Forbidden):
- Cadence-based detection in tick loops
- Tick-jitter padding or lead-time inflation
- Loop-frequency-dependent correctness
- Runtime "catch-up" issuance after missed cadence
- Health-check-triggered switch issuance
- Polling-based approximation of deadline timing

Anti-Patterns (FORBIDDEN):
```python
# WRONG: Cadence-based detection in tick loop
async def tick(self):
    now = datetime.now(timezone.utc)
    if now >= self._switch_at:  # VIOLATION: cadence-based detection
        await self._issue_switch_to_live()
```

```python
# WRONG: Inflating lead time to absorb tick jitter
_switch_lead_seconds = MIN_PREFEED_LEAD_TIME + 1  # VIOLATION: jitter padding
```

```python
# WRONG: Loop frequency determines correctness
async def run(self):
    while True:
        await asyncio.sleep(0.5)  # VIOLATION: correctness depends on sleep interval
        self._check_pending_switches()
```

```python
# WRONG: Catch-up issuance after missed cadence
if now > switch_at and not switch_issued:
    logger.warning("late issuance")  # VIOLATION: runtime catch-up
    await self._issue_switch_to_live()
```

Correct Pattern:
```python
# RIGHT: Deadline-scheduled issuance via event loop primitive
def _schedule_switch_issuance(self, boundary_time: datetime) -> None:
    issue_at = boundary_time - MIN_PREFEED_LEAD_TIME
    delay = (issue_at - datetime.now(timezone.utc)).total_seconds()

    # Register timed callback at plan time; event loop fires at deadline
    self._loop.call_later(delay, self._issue_switch_to_live_callback, boundary_time)
```

Done Criteria:
- Switch issuance registered with event loop at plan time (not discovered by tick)
- No cadence-based `if now >= switch_at` patterns in codebase
- No tick-jitter padding or lead-time inflation
- Issuance occurs no later than `issue_at` (early is permitted)
- Late issuance treated as fatal
- Happy path test (P11D-006) passes: switches issued at deadline, not detected by tick

---
**Done:** Implemented `_schedule_switch_issuance(boundary_time)` using `threading.Timer(delay, _on_switch_issue_deadline)`. Timer registered at plan time (line 737, 1147); fires at `issue_at = boundary_time - MIN_PREFEED_LEAD_TIME - 0.5s`. Late issuance (>50ms past issue_at) triggers FATAL SchedulingError. No cadence-based `if now >= switch_at` patterns remain in tick().
