Task ID: P11D-012
Rule ID: INV-LEADTIME-MEASUREMENT-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: Core → AIR protocol
Task Type: FIX
File(s) to Modify: protos/playout.proto, pkg/core/src/retrovue/usecases/channel_manager_launch.py, pkg/air/src/playout_service.cpp, pkg/air/src/runtime/PlayoutEngine.cpp
Owner: Core + AIR
Blocked By: P11D-011
Blocks: P11D-006

Instructions:
- Add `issued_at_time_ms` to legacy switch RPCRequest proto
- Core MUST populate `issued_at_time_ms` at issuance moment
- AIR MUST use `issued_at_time_ms` (not receipt time) for lead-time evaluation
- Log transport delta for clock skew detection

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

If switch execution is deadline-authoritative, lead-time evaluation must be based on authoritative issuance time, not variable receipt time. RPC transport latency is not under caller control and must not affect feasibility.

Rule Definition (INV-LEADTIME-MEASUREMENT-001):

Lead time MUST be evaluated using `issued_at_time_ms` from Core, not AIR receipt time. Transport latency MUST NOT consume the lead time budget.

```
lead_time = target_boundary_time_ms - issued_at_time_ms
```

Core populates `issued_at_time_ms` at the moment legacy switch RPC is issued. AIR uses this value for lead-time feasibility. If `issued_at_time_ms` is absent or zero, receipt-time evaluation applies for backward compatibility only; this mode is deprecated and MUST NOT be relied upon by Core.

**Derivation:**

| Parent Rule | Relationship |
|-------------|--------------|
| LAW-AUTHORITY-HIERARCHY | Clock authority is absolute; measurement must use authoritative timestamps |
| INV-SWITCH-ISSUANCE-DEADLINE-001 | Issuance is deadline-scheduled at `issue_at`; that timestamp is authoritative |
| INV-CONTROL-NO-POLL-001 | No retry semantics; RPC latency must not create false violations |

Root Cause Being Addressed:

Core issues legacy switch RPC at exactly `boundary_time - MIN_PREFEED_LEAD_TIME`. AIR evaluates lead time using receipt time. Any RPC latency causes:

```
lead_time_AIR = target - receipt_time
             = target - (issued_at + transport_latency)
             = (target - issued_at) - transport_latency
             = MIN_PREFEED - transport_latency
             < MIN_PREFEED  (always, if transport_latency > 0)
```

This guarantees rejection whenever transport latency is non-zero.

Implementation:

1. Proto (protos/playout.proto):
   ```protobuf
   message legacy switch RPCRequest {
     int32 channel_id = 1;
     int64 target_boundary_time_ms = 2;
     int64 issued_at_time_ms = 3;  // P11D-012: Wall-clock ms when Core issued this request
   }
   ```

2. Core (channel_manager_launch.py):
   ```python
   # P11D-012: INV-LEADTIME-MEASUREMENT-001 — issued_at_time_ms for lead-time evaluation
   issued_at_time_ms = int(time.time() * 1000)
   r = stub.legacy switch RPC(
       playout_pb2.legacy switch RPCRequest(
           channel_id=channel_id_int,
           target_boundary_time_ms=target_boundary_time_ms,
           issued_at_time_ms=issued_at_time_ms,
       ),
       timeout=timeout_s,
   )
   ```

3. AIR gRPC handler (playout_service.cpp):
   ```cpp
   const int64_t issued_at_time_ms = request->issued_at_time_ms();  // P11D-012
   auto result = interface_->legacy switch RPC(channel_id, target_boundary_time_ms, issued_at_time_ms);
   ```

4. AIR engine (PlayoutEngine.cpp):
   ```cpp
   // P11D-012: INV-LEADTIME-MEASUREMENT-001 — use issuance time, not receipt time
   const int64_t evaluation_time_ms = (issued_at_time_ms > 0) ? issued_at_time_ms : now_ms;
   const int64_t lead_time_ms = target_boundary_time_ms - evaluation_time_ms;
   ```

5. Clock skew detection logging:
   ```cpp
   if (issued_at_time_ms > 0) {
     const int64_t transport_delta_ms = now_ms - issued_at_time_ms;
     std::cout << "[legacy switch RPC] INV-LEADTIME-MEASUREMENT-001: issued_at_time_ms=" << issued_at_time_ms
               << " receipt_time_ms=" << now_ms
               << " transport_delta_ms=" << transport_delta_ms
               << " lead_time_ms=" << lead_time_ms << std::endl;
     if (transport_delta_ms < -1000 || transport_delta_ms > 1000) {
       std::cout << "[legacy switch RPC] WARN: Clock skew detected" << std::endl;
     }
   }
   ```

Constraints:
- `issued_at_time_ms` MUST be populated by Core at issuance moment
- AIR MUST use `issued_at_time_ms` for lead-time calculation when non-zero
- AIR MUST fall back to receipt time if `issued_at_time_ms == 0` (backward compatibility)
- Transport delta > 1 second MUST be logged as clock skew warning
- Negative transport delta (AIR time < Core time) indicates clock skew

Done Criteria:
- Proto includes `issued_at_time_ms` field
- Core populates `issued_at_time_ms` at issuance
- AIR uses `issued_at_time_ms` for lead-time evaluation
- Clock skew detection logging present
- Happy path test (P11D-006) passes: RPC latency no longer causes false violations

---
**Done:** Proto field added (playout.proto:133). Core populates `issued_at_time_ms = int(time.time() * 1000)` at issuance (channel_manager_launch.py:282, 496). AIR extracts field (playout_service.cpp:266), computes `evaluation_time_ms = issued_at_time_ms > 0 ? issued_at_time_ms : now_ms` (PlayoutEngine.cpp:888), logs transport delta and clock skew warnings. Receipt-time mode deprecated per ledger addendum.
