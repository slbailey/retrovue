Task ID: P11E-005
Rule ID: INV-CONTROL-NO-POLL-001
Subsystem: Integration
Task Type: TEST
File(s) to Modify: pkg/core/tests/integration/test_prefeed_timing.py (new file)
Owner: Test
Blocked By: P11E-003

Instructions:
- Create contract test verifying all LoadPreview calls have ≥MIN_PREFEED_LEAD_TIME_MS
- Test scheduling scenarios that could violate the constraint

---

Rule Definition:
Core MUST issue LoadPreview with sufficient lead time that AIR can achieve readiness before the declared boundary time.

Test Scenarios:

1. TEST_INV_CONTROL_NO_POLL_001_NormalScheduling
   - Given: Normal scheduling loop with boundaries 30+ seconds away
   - When: Scheduling tick runs
   - Then: All LoadPreview calls have ≥MIN_PREFEED_LEAD_TIME

2. TEST_INV_CONTROL_NO_POLL_001_LateStart
   - Given: Scheduling starts with boundary < MIN_PREFEED_LEAD_TIME away
   - When: First scheduling tick runs
   - Then: Violation is logged but LoadPreview still issued

3. TEST_INV_CONTROL_NO_POLL_001_RapidBoundaries
   - Given: Multiple boundaries in quick succession
   - When: Scheduling tick runs
   - Then: All LoadPreview calls have correct lead time

Test Implementation:

```python
# pkg/core/tests/integration/test_prefeed_timing.py

import pytest
from datetime import datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock, patch
from retrovue.runtime.channel_manager import ChannelManager
from retrovue.runtime.constants import MIN_PREFEED_LEAD_TIME, MIN_PREFEED_LEAD_TIME_MS


class TestPrefeedTiming:

    @pytest.fixture
    def mock_air_client(self):
        client = AsyncMock()
        client.load_preview.return_value = MagicMock(status='OK')
        return client

    @pytest.fixture
    def mock_schedule_manager(self):
        return MagicMock()

    @pytest.fixture
    def channel_manager(self, mock_air_client, mock_schedule_manager):
        return ChannelManager(
            air_client=mock_air_client,
            schedule_manager=mock_schedule_manager
        )

    async def test_normal_scheduling_has_sufficient_lead_time(
        self, channel_manager, mock_schedule_manager, mock_air_client
    ):
        """INV-CONTROL-NO-POLL-001: Normal scheduling provides sufficient lead time."""
        # Arrange: Boundary 30 seconds in future
        now = datetime.now(timezone.utc)
        boundary_time = now + timedelta(seconds=30)

        mock_schedule_manager.get_upcoming_boundaries.return_value = [
            MagicMock(time=boundary_time, plan_handle='test_plan')
        ]

        # Act: Run scheduling tick
        await channel_manager._scheduling_tick()

        # Assert: LoadPreview called with sufficient lead time
        assert mock_air_client.load_preview.called
        call_args = mock_air_client.load_preview.call_args
        request = call_args[0][0]

        # Calculate actual lead time at time of call
        # (would need to capture time inside the call)
        # For this test, verify the request contains correct boundary
        assert request.target_boundary_time_ms == int(boundary_time.timestamp() * 1000)

    async def test_late_start_logs_violation(
        self, channel_manager, mock_schedule_manager, caplog
    ):
        """INV-CONTROL-NO-POLL-001: Late start logs violation but proceeds."""
        # Arrange: Boundary only 2 seconds away (violation)
        now = datetime.now(timezone.utc)
        boundary_time = now + timedelta(seconds=2)

        mock_schedule_manager.get_upcoming_boundaries.return_value = [
            MagicMock(time=boundary_time, plan_handle='test_plan')
        ]

        # Act
        await channel_manager._scheduling_tick()

        # Assert: Violation logged
        assert 'INV-CONTROL-NO-POLL-001 VIOLATION' in caplog.text
        assert 'insufficient lead time' in caplog.text.lower()

    async def test_all_prefeeds_tracked_in_metrics(
        self, channel_manager, mock_schedule_manager, mock_air_client
    ):
        """INV-CONTROL-NO-POLL-001: All prefeeds recorded in histogram metric."""
        # Arrange: Multiple boundaries
        now = datetime.now(timezone.utc)
        boundaries = [
            MagicMock(time=now + timedelta(seconds=10), plan_handle='plan_1'),
            MagicMock(time=now + timedelta(seconds=40), plan_handle='plan_2'),
            MagicMock(time=now + timedelta(seconds=70), plan_handle='plan_3'),
        ]

        mock_schedule_manager.get_upcoming_boundaries.return_value = boundaries

        # Act
        with patch('retrovue.runtime.channel_manager.metrics') as mock_metrics:
            await channel_manager._scheduling_tick()

            # Assert: Histogram observed for each boundary within trigger window
            assert mock_metrics.prefeed_lead_time_ms.labels.called

    async def test_boundary_imminent_on_startup(
        self, channel_manager, mock_schedule_manager, mock_air_client, caplog
    ):
        """Test handling of imminent boundary when scheduling starts."""
        # Arrange: Boundary in 500ms (way too close)
        now = datetime.now(timezone.utc)
        boundary_time = now + timedelta(milliseconds=500)

        mock_schedule_manager.get_upcoming_boundaries.return_value = [
            MagicMock(time=boundary_time, plan_handle='test_plan')
        ]

        # Act
        await channel_manager._scheduling_tick()

        # Assert: Violation logged but operation attempted
        assert 'VIOLATION' in caplog.text
        # AIR will handle with safety rails

    async def test_lead_time_calculated_correctly(self, channel_manager):
        """Verify lead time calculation logic."""
        now = datetime.now(timezone.utc)
        boundary = MagicMock(time=now + timedelta(seconds=10))

        trigger_time = channel_manager._get_load_preview_trigger_time(boundary)

        # Trigger should be before boundary by (MIN_PREFEED_LEAD_TIME + buffer)
        expected_trigger = boundary.time - MIN_PREFEED_LEAD_TIME - timedelta(seconds=2)
        assert trigger_time == expected_trigger


class TestPrefeedTimingEdgeCases:

    async def test_boundary_in_past_is_skipped(
        self, channel_manager, mock_schedule_manager, mock_air_client
    ):
        """Boundaries in the past should be skipped."""
        now = datetime.now(timezone.utc)
        past_boundary = MagicMock(time=now - timedelta(seconds=5), plan_handle='past')

        mock_schedule_manager.get_upcoming_boundaries.return_value = [past_boundary]

        await channel_manager._scheduling_tick()

        # Should not attempt LoadPreview for past boundary
        assert not mock_air_client.load_preview.called

    async def test_duplicate_load_preview_prevented(
        self, channel_manager, mock_schedule_manager, mock_air_client
    ):
        """LoadPreview should only be issued once per boundary."""
        now = datetime.now(timezone.utc)
        boundary = MagicMock(time=now + timedelta(seconds=10), plan_handle='test')

        mock_schedule_manager.get_upcoming_boundaries.return_value = [boundary]

        # First tick
        await channel_manager._scheduling_tick()
        # Second tick
        await channel_manager._scheduling_tick()

        # Should only call once
        assert mock_air_client.load_preview.call_count == 1
```

Assertions Required:
1. Normal scheduling provides ≥MIN_PREFEED_LEAD_TIME
2. Late start logs violation but proceeds
3. All prefeeds tracked in metrics
4. Edge cases handled (past boundaries, duplicates)

Done Criteria:
Contract tests prove all LoadPreview calls have ≥MIN_PREFEED_LEAD_TIME_MS except for documented edge cases.

---
**Done:** `pkg/core/tests/runtime/test_prefeed_timing.py` contains tests: `test_min_prefeed_lead_time_ms_in_valid_range`, `test_preload_trigger_lead_exceeds_min`, `test_switch_to_live_logs_violation_when_lead_insufficient`, `test_switch_to_live_no_violation_log_when_lead_sufficient`, `test_switch_lead_time_observed_when_metrics_available`.
