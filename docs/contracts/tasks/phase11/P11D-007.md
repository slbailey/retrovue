Task ID: P11D-007
Rule ID: INV-BOUNDARY-TOLERANCE-001, INV-SWITCH-DEADLINE-AUTHORITATIVE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: Integration
Task Type: TEST
File(s) to Modify: pkg/air/tests/integration/DeadlineSwitchTests.cpp (new file)
Owner: Test
Blocked By: P11D-002

Instructions:
- Create contract test verifying switch executes within 1 frame of declared boundary
- Test must measure actual switch time vs declared boundary time
- **Critical: Test must verify clock wins over frame completion (LAW-AUTHORITY-HIERARCHY)**

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

This test suite validates the authority hierarchy by proving:
1. Switch executes at clock time (not when frames are ready)
2. Frame completion does NOT delay switch execution
3. If content isn't ready, switch still executes (with safety rails)

Rule Definition:
Grid transitions MUST complete within one video frame duration (33.33ms at 30fps) of the scheduled absolute boundary time.

Test Scenario:
TEST_INV_BOUNDARY_TOLERANCE_001_SwitchWithinOneFrame

- Given: Declared boundary time T
- When: Switch is scheduled and executed
- Then: Actual switch completion time is within [T - 33ms, T + 33ms]

Test Implementation:

```cpp
class DeadlineSwitchTests : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize test harness with MasterClock control
        master_clock_ = std::make_unique<MockMasterClock>();
        playout_engine_ = std::make_unique<PlayoutEngine>(master_clock_.get());

        // Load preview content
        playout_engine_->LoadPreview(channel_id_, test_plan_handle_);
        WaitForPreviewReady();
    }

    static constexpr int64_t kFrameDurationMs = 33;  // ~30fps
    static constexpr int64_t channel_id_ = 1;
    std::string test_plan_handle_ = "test_plan_001";
};

TEST_F(DeadlineSwitchTests, SwitchWithinOneFrame) {
    // Arrange: Set target boundary 5 seconds in the future
    int64_t now_ms = master_clock_->NowMs();
    int64_t target_boundary_ms = now_ms + 5000;

    // Act: Issue SwitchToLive with target boundary
    SwitchToLiveRequest request;
    request.set_channel_id(channel_id_);
    request.set_target_boundary_time_ms(target_boundary_ms);

    SwitchToLiveResponse response;
    auto status = playout_engine_->SwitchToLive(request, &response);

    ASSERT_TRUE(status.ok());
    ASSERT_EQ(response.status(), SWITCH_STATUS_OK);

    // Advance clock to target time
    master_clock_->AdvanceTo(target_boundary_ms);

    // Get actual switch completion time
    int64_t actual_switch_time_ms = response.switch_completion_time_ms();

    // Assert: Within 1 frame tolerance
    int64_t delta_ms = std::abs(actual_switch_time_ms - target_boundary_ms);

    EXPECT_LE(delta_ms, kFrameDurationMs)
        << "INV-BOUNDARY-TOLERANCE-001 VIOLATION: Switch completed at " << actual_switch_time_ms
        << " but boundary was " << target_boundary_ms
        << " (delta: " << delta_ms << "ms, max allowed: " << kFrameDurationMs << "ms)";
}

TEST_F(DeadlineSwitchTests, SwitchAtDeadlineEvenIfNotReady) {
    // Arrange: Do NOT load preview, so readiness will be false
    playout_engine_->UnloadPreview(channel_id_);

    int64_t now_ms = master_clock_->NowMs();
    int64_t target_boundary_ms = now_ms + 5000;

    // Act: Issue SwitchToLive
    SwitchToLiveRequest request;
    request.set_channel_id(channel_id_);
    request.set_target_boundary_time_ms(target_boundary_ms);

    SwitchToLiveResponse response;
    auto status = playout_engine_->SwitchToLive(request, &response);

    ASSERT_TRUE(status.ok());
    ASSERT_EQ(response.status(), SWITCH_STATUS_OK);  // Should NOT be NOT_READY

    // Advance clock to target time
    master_clock_->AdvanceTo(target_boundary_ms);

    // Assert: Switch still completed at target time (using safety rails)
    int64_t actual_switch_time_ms = response.switch_completion_time_ms();
    int64_t delta_ms = std::abs(actual_switch_time_ms - target_boundary_ms);

    EXPECT_LE(delta_ms, kFrameDurationMs)
        << "INV-SWITCH-DEADLINE-AUTHORITATIVE-001: Switch must execute at deadline even if not ready";

    // Assert: Log indicates safety rails engaged
    EXPECT_TRUE(LogContains("Safety rails engaged"));
}

TEST_F(DeadlineSwitchTests, MultiSwitchBoundaryAccuracy) {
    // Arrange: Schedule multiple switches at different boundaries
    std::vector<int64_t> boundaries;
    int64_t now_ms = master_clock_->NowMs();

    for (int i = 0; i < 10; i++) {
        boundaries.push_back(now_ms + (i + 1) * 30000);  // Every 30 seconds
    }

    std::vector<int64_t> deltas;

    for (int64_t boundary : boundaries) {
        // Load fresh preview
        playout_engine_->LoadPreview(channel_id_, "plan_" + std::to_string(boundary));
        WaitForPreviewReady();

        // Issue switch
        SwitchToLiveRequest request;
        request.set_channel_id(channel_id_);
        request.set_target_boundary_time_ms(boundary);

        SwitchToLiveResponse response;
        playout_engine_->SwitchToLive(request, &response);

        // Advance to boundary
        master_clock_->AdvanceTo(boundary);

        int64_t delta = std::abs(response.switch_completion_time_ms() - boundary);
        deltas.push_back(delta);
    }

    // Assert: ALL switches within tolerance
    for (size_t i = 0; i < deltas.size(); i++) {
        EXPECT_LE(deltas[i], kFrameDurationMs)
            << "Switch " << i << " violated boundary tolerance";
    }
}
```

Assertions Required:
1. Single switch completes within 1 frame of declared boundary
2. Switch executes at deadline even if preview not ready
3. Multiple consecutive switches all meet tolerance

Done Criteria:
All contract tests pass proving switch executes within 1 frame of declared boundary time.
