Task ID: P11D-004
Rule ID: INV-CONTROL-NO-POLL-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: PlayoutEngine/gRPC
Task Type: FIX
File(s) to Modify: pkg/air/src/grpc/PlayoutServiceImpl.cpp, pkg/air/proto/playout.proto
Owner: AIR
Blocked By: P11D-002

Instructions:
- Deprecate NOT_READY response from SwitchToLive
- Replace with PROTOCOL_VIOLATION if prefeed was late
- NOT_READY should never be returned in deadline-authoritative mode

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

NOT_READY implies "wait and retry until frames are ready" — this inverts the hierarchy. Under clock authority, readiness is AIR's internal concern, not a blocking condition. If prefeed timing was violated, that's a protocol error (Core's fault), not a "try again" situation.

Rule Definition (INV-CONTROL-NO-POLL-001):
SwitchToLive MUST NOT return NOT_READY requiring Core to poll/retry. If prefeed timing was violated, return PROTOCOL_VIOLATION.

Implementation:

1. Update SwitchToLiveResponse proto:
   ```protobuf
   enum SwitchStatus {
       SWITCH_STATUS_UNSPECIFIED = 0;
       SWITCH_STATUS_OK = 1;
       SWITCH_STATUS_NOT_READY = 2 [deprecated = true];  // Do not use in deadline-authoritative mode
       SWITCH_STATUS_PROTOCOL_VIOLATION = 3;  // NEW: Prefeed timing violated
       SWITCH_STATUS_INVALID_CHANNEL = 4;
       SWITCH_STATUS_INTERNAL_ERROR = 5;
   }

   message SwitchToLiveResponse {
       SwitchStatus status = 1;
       int64 switch_completion_time_ms = 2;
       string violation_reason = 3;  // NEW: Populated when status is PROTOCOL_VIOLATION
   }
   ```

2. Update SwitchToLive handler:
   ```cpp
   grpc::Status SwitchToLive(ServerContext* context,
                              const SwitchToLiveRequest* request,
                              SwitchToLiveResponse* response) {
       int64_t target_time_ms = request->target_boundary_time_ms();

       if (target_time_ms > 0) {
           // Deadline-authoritative mode
           int64_t now_ms = MasterClock::Now().ToEpochMs();
           int64_t lead_time_ms = target_time_ms - now_ms;

           if (lead_time_ms < MIN_PREFEED_LEAD_TIME_MS) {
               // Prefeed timing violated — log and return protocol violation
               LOG_ERROR("[PlayoutService] INV-CONTROL-NO-POLL-001 VIOLATION: "
                         "SwitchToLive received with insufficient lead time (%ld ms < %ld ms required)",
                         lead_time_ms, MIN_PREFEED_LEAD_TIME_MS);

               response->set_status(SWITCH_STATUS_PROTOCOL_VIOLATION);
               response->set_violation_reason("Insufficient prefeed lead time");
               return grpc::Status::OK;  // Return OK status with error in response
           }

           // Schedule switch at target time
           ScheduleSwitchAt(request->channel_id(), target_time_ms);
           response->set_status(SWITCH_STATUS_OK);
           response->set_switch_completion_time_ms(target_time_ms);
       } else {
           // Legacy mode (backward compatibility)
           // Execute immediately or return NOT_READY if truly unready
           // NOTE: Legacy mode will be removed in future phase
       }

       return grpc::Status::OK;
   }
   ```

3. Add violation reason enum (optional):
   ```protobuf
   enum ViolationReason {
       VIOLATION_REASON_UNSPECIFIED = 0;
       VIOLATION_REASON_INSUFFICIENT_LEAD_TIME = 1;
       VIOLATION_REASON_NO_PREVIEW_LOADED = 2;
   }
   ```

Log Specification:

Protocol violation:
```
[PlayoutService] INV-CONTROL-NO-POLL-001 VIOLATION: SwitchToLive received with insufficient lead time (500 ms < 5000 ms required)
```

Constraints:
- NOT_READY response is deprecated but kept for backward compatibility
- New code MUST NOT return NOT_READY in deadline-authoritative mode
- PROTOCOL_VIOLATION is a terminal error — Core must not retry
- Include actionable violation_reason for debugging

Done Criteria:
SwitchToLive in deadline-authoritative mode never returns NOT_READY; late prefeed returns PROTOCOL_VIOLATION.
