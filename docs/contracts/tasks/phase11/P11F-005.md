Task ID: P11F-005
Rule ID: INV-SWITCH-ISSUANCE-DEADLINE-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager
Task Type: FIX
File(s) to Modify: pkg/core/src/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P11F-002

Instructions:
- Replace threading.Timer with loop.call_later()
- Keep all timer logic inside the event loop
- Simplify teardown (no cross-thread issues)

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

Rule Definition (INV-SWITCH-ISSUANCE-DEADLINE-001) — Tightened:
legacy switch RPC issuance MUST be deadline-scheduled via `loop.call_later()`, not `threading.Timer`. This keeps all timer logic inside the event loop and avoids cross-thread issues.

Implementation:

1. Replace threading.Timer with loop.call_later():
   ```python
   def _schedule_switch_issuance(self, boundary_time: datetime) -> None:
       """P11D-011 INV-SWITCH-ISSUANCE-DEADLINE-001: One-shot via event loop."""
       if boundary_time.tzinfo is None:
           boundary_time = boundary_time.replace(tzinfo=timezone.utc)

       _ISSUANCE_BUFFER = timedelta(seconds=0.5)
       issue_at = boundary_time - MIN_PREFEED_LEAD_TIME - _ISSUANCE_BUFFER
       now = self.clock.now_utc()
       if now.tzinfo is None:
           now = now.replace(tzinfo=timezone.utc)
       delay_s = (issue_at - now).total_seconds()

       # Cancel any existing handle (shouldn't happen per ONESHOT invariant)
       if self._switch_handle is not None:
           self._switch_handle.cancel()
           self._switch_handle = None

       if delay_s <= 0:
           # Already past issue_at — immediate issuance
           self._on_switch_issue_deadline_sync(boundary_time)
           return

       loop = asyncio.get_running_loop()
       self._switch_handle = loop.call_later(
           delay_s,
           self._on_switch_issue_deadline_sync,
           boundary_time
       )

       self._logger.info(
           "INV-SWITCH-ISSUANCE-DEADLINE-001: Switch scheduled for %s (delay=%.2fs)",
           boundary_time.isoformat(), delay_s
       )
   ```

2. Add sync wrapper that creates async task:
   ```python
   def _on_switch_issue_deadline_sync(self, boundary_time: datetime) -> None:
       """Sync callback for loop.call_later(); creates async task."""
       asyncio.create_task(self._on_switch_issue_deadline(boundary_time))
   ```

3. Add handle attribute in __init__:
   ```python
   self._switch_handle: Optional[asyncio.TimerHandle] = None
   ```

4. Cancel on teardown:
   ```python
   async def stop(self) -> None:
       if self._switch_handle is not None:
           self._switch_handle.cancel()
           self._switch_handle = None
       # ... rest of teardown ...
   ```

Constraints:
- MUST use loop.call_later(), not threading.Timer
- Timer callback must create async task (not await directly)
- Handle must be cancelled on teardown
- No cross-thread async calls

Done Criteria:
Switch issuance uses loop.call_later(); no threading.Timer in switch path; teardown cancels handle.

---

## Completion Status

| Field | Value |
|-------|-------|
| **Status** | COMPLETE |
| **Completed** | 2026-02-02 |
| **Implementation** | Optional event_loop parameter on ChannelManager.__init__; when set, _schedule_switch_issuance uses loop.call_soon_thread_safe(_schedule_switch_issuance_on_loop, boundary_time, delay_s); _schedule_switch_issuance_on_loop runs on loop thread and uses loop.call_later(delay_s, _on_switch_issue_deadline, boundary_time). _switch_handle stored and cancelled in stop_channel. When event_loop is None, threading.Timer retained for tests. |
| **Tests** | 32 runtime tests passed (no loop passed; Timer path used). |
