Task ID: P11F-006
Rule ID: INV-BOUNDARY-DECLARED-MATCHES-PLAN-001
Governing Law: LAW-AUTHORITY-HIERARCHY
Subsystem: ChannelManager
Task Type: FIX
File(s) to Modify: pkg/core/src/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P11F-002

Instructions:
- Validate target_boundary_ms against plan-derived boundary
- Reject if they don't match
- Prevents "now + X" drift bugs

---

Governing Principle (LAW-AUTHORITY-HIERARCHY):
> Clock authority supersedes frame completion for switch execution.

Rule Definition (INV-BOUNDARY-DECLARED-MATCHES-PLAN-001):
The `target_boundary_ms` sent to AIR MUST equal the boundary computed from the active playout plan (segment boundary, block boundary), NOT a derived `now + X` value.

Implementation:

1. Store plan-derived boundary when planning:
   ```python
   def _plan_boundary(self, boundary_time: datetime) -> None:
       # ... feasibility validation ...

       # Store plan-derived boundary for later validation
       self._plan_boundary_ms = int(boundary_time.timestamp() * 1000)

       # Schedule legacy preload RPC and switch issuance
       self._schedule_load_preview(boundary_time)
       self._schedule_switch_issuance(boundary_time)
       self._transition_boundary_state(BoundaryState.PLANNED)
   ```

2. Add validation in _issue_switch_to_live():
   ```python
   async def _issue_switch_to_live_impl(self, boundary_time: datetime) -> None:
       target_boundary_ms = int(boundary_time.timestamp() * 1000)

       # INV-BOUNDARY-DECLARED-MATCHES-PLAN-001: Must match plan
       if self._plan_boundary_ms is not None and target_boundary_ms != self._plan_boundary_ms:
           self._logger.error(
               "INV-BOUNDARY-DECLARED-MATCHES-PLAN-001 FATAL: target_boundary_ms=%d does not match plan boundary=%d",
               target_boundary_ms, self._plan_boundary_ms
           )
           self._transition_boundary_state(BoundaryState.FAILED_TERMINAL)
           self._pending_fatal = SchedulingError(
               f"Boundary mismatch: target={target_boundary_ms}, plan={self._plan_boundary_ms}"
           )
           return

       # ... proceed with RPC ...
   ```

3. Clear plan boundary on transition to NONE:
   ```python
   def _transition_boundary_state(self, new_state: BoundaryState) -> None:
       # ... existing logic ...

       if new_state == BoundaryState.NONE:
           self._plan_boundary_ms = None

       self._boundary_state = new_state
   ```

Rationale:
Boundaries derived from `now + lead_time` drift with execution timing and retry attempts. Plan-derived boundaries are deterministic and auditable. This invariant catches:
- Retry logic that recalculates boundary from current time
- Launch paths that use "now + 6s" instead of segment boundary
- Any code that mutates boundary_time after planning

Done Criteria:
target_boundary_ms validated against plan boundary; mismatch results in FAILED_TERMINAL; no "now + X" drift possible.

---

## Completion Status

| Field | Value |
|-------|-------|
| **Status** | COMPLETE |
| **Completed** | 2026-02-02 |
| **Implementation** | _plan_boundary_ms set when _segment_end_time_utc is set (start() and _handle_switch_complete); cleared in _transition_boundary_state when new_state == NONE. In _on_switch_issue_deadline, target_boundary_ms validated against _plan_boundary_ms; mismatch â†’ FAILED_TERMINAL and _pending_fatal. |
| **Tests** | 32 runtime tests passed. |
