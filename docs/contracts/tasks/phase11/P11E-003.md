Task ID: P11E-003
Rule ID: INV-CONTROL-NO-POLL-001
Subsystem: ChannelManager
Task Type: LOG
File(s) to Modify: pkg/core/retrovue/runtime/channel_manager.py
Owner: Core
Blocked By: P11E-002

Instructions:
- Log violation if LoadPreview issued with less than MIN_PREFEED_LEAD_TIME_MS
- This indicates a scheduling bug in Core

---

Rule Definition:
Core MUST issue LoadPreview with sufficient lead time. If this constraint is violated, it represents a Core scheduling bug.

Implementation:

1. Add violation check in _issue_load_preview:
   ```python
   async def _issue_load_preview(self, channel_id: int, boundary: GridBoundary):
       """Issue LoadPreview for upcoming boundary."""
       now = datetime.now(timezone.utc)
       lead_time = boundary.time - now
       lead_time_ms = int(lead_time.total_seconds() * 1000)

       # Check for timing violation
       if lead_time < MIN_PREFEED_LEAD_TIME:
           logger.error(
               f"INV-CONTROL-NO-POLL-001 VIOLATION: LoadPreview issued with insufficient lead time. "
               f"channel_id={channel_id}, "
               f"boundary={boundary.time.isoformat()}, "
               f"lead_time_ms={lead_time_ms}, "
               f"min_required_ms={MIN_PREFEED_LEAD_TIME_MS}. "
               f"This is a Core scheduling bug."
           )
           # Increment violation metric
           metrics.increment('prefeed_lead_time_violations_total', {
               'channel_id': str(channel_id)
           })

       # Proceed anyway — AIR will use safety rails if needed
       # But the violation is logged for debugging
       ...
   ```

2. Add violation check in _issue_switch_to_live:
   ```python
   async def _issue_switch_to_live(self, channel_id: int, boundary: GridBoundary):
       """Issue SwitchToLive for upcoming boundary."""
       now = datetime.now(timezone.utc)
       lead_time = boundary.time - now

       if lead_time < MIN_PREFEED_LEAD_TIME:
           logger.error(
               f"INV-CONTROL-NO-POLL-001 VIOLATION: SwitchToLive issued too late. "
               f"channel_id={channel_id}, "
               f"boundary={boundary.time.isoformat()}, "
               f"lead_time_ms={int(lead_time.total_seconds() * 1000)}, "
               f"min_required_ms={MIN_PREFEED_LEAD_TIME_MS}. "
               f"AIR may return PROTOCOL_VIOLATION."
           )
           metrics.increment('switch_lead_time_violations_total', {
               'channel_id': str(channel_id)
           })

       # Proceed — let AIR determine if violation is fatal
       ...
   ```

Log Specification:

LoadPreview violation:
```
INV-CONTROL-NO-POLL-001 VIOLATION: LoadPreview issued with insufficient lead time. channel_id=1, boundary=2026-02-01T12:30:00Z, lead_time_ms=2500, min_required_ms=5000. This is a Core scheduling bug.
```

SwitchToLive violation:
```
INV-CONTROL-NO-POLL-001 VIOLATION: SwitchToLive issued too late. channel_id=1, boundary=2026-02-01T12:30:00Z, lead_time_ms=3000, min_required_ms=5000. AIR may return PROTOCOL_VIOLATION.
```

Metrics:
- `prefeed_lead_time_violations_total` — counter of LoadPreview timing violations
- `switch_lead_time_violations_total` — counter of SwitchToLive timing violations

Constraints:
- Violations MUST be logged even if we proceed
- Metric MUST be incremented for monitoring/alerting
- Log MUST include all context needed for debugging
- Do NOT fail silently — visibility is critical

Done Criteria:
All timing violations are logged with full context; metrics incremented for monitoring.

---
**Done:** `switch_to_live()` in channel_manager.py logs `INV-CONTROL-NO-POLL-001 VIOLATION: SwitchToLive issued too late` with `lead_time_ms`, `min_required_ms`, `channel_id`. Test `test_switch_to_live_logs_violation_when_lead_insufficient` verifies violation detection.
